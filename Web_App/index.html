<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Collide Size Curve Explorer</title>
    <style>
      :root {
        color-scheme: light dark;
        font-family: "Inter", "Segoe UI", system-ui, sans-serif;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        background: radial-gradient(circle at 15% 20%, #29326a, #0c101f 55%, #07090f 100%);
        color: #f4f6ff;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
      }

      .tab-bar {
        display: flex;
        justify-content: center;
        gap: 12px;
        padding: 16px 20px 8px;
        background: rgba(9, 12, 24, 0.9);
        border-bottom: 1px solid rgba(120, 143, 255, 0.15);
      }

      .tab-button {
        appearance: none;
        border: 1px solid rgba(128, 149, 255, 0.4);
        background: rgba(20, 26, 48, 0.75);
        color: #f4f6ff;
        padding: 10px 18px;
        border-radius: 999px;
        font-size: 0.85rem;
        letter-spacing: 0.05em;
        text-transform: uppercase;
        cursor: pointer;
        transition: background 0.18s ease, color 0.18s ease;
      }

      .tab-button.active {
        background: linear-gradient(135deg, rgba(119, 137, 255, 0.95), rgba(140, 99, 255, 0.95));
        border-color: transparent;
      }

      .hidden {
        display: none !important;
      }

      .app {
        display: flex;
        flex-direction: column;
        width: 100%;
        min-height: 0;
        flex: 1;
      }

      .control-panel {
        width: 360px;
        padding: 32px 28px 40px;
        background: rgba(13, 18, 36, 0.86);
        backdrop-filter: blur(18px);
        border-right: 1px solid rgba(130, 155, 255, 0.18);
        display: flex;
        flex-direction: column;
        gap: 28px;
      }

      .panel-intro {
        display: grid;
        gap: 8px;
      }

      .archetype-panel {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        padding: 12px 14px;
        margin-bottom: 20px;
        border: 1px solid rgba(128, 149, 255, 0.25);
        border-radius: 14px;
        background: rgba(20, 26, 48, 0.6);
      }

      .archetype-label {
        font-size: 0.78rem;
        font-weight: 600;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: rgba(146, 165, 255, 0.85);
      }

      .archetype-buttons {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }

      .archetype-button {
        appearance: none;
        border: 1px solid rgba(128, 149, 255, 0.35);
        background: rgba(18, 24, 44, 0.75);
        color: #f4f6ff;
        padding: 6px 14px;
        border-radius: 12px;
        font-size: 0.78rem;
        letter-spacing: 0.06em;
        text-transform: uppercase;
        cursor: pointer;
        transition: background 0.18s ease, color 0.18s ease, border 0.18s ease;
      }

      .archetype-button.active {
        background: linear-gradient(135deg, rgba(119, 137, 255, 0.95), rgba(140, 99, 255, 0.95));
        border-color: transparent;
      }

      .product-tab-bar {
        display: flex;
        gap: 12px;
        margin-bottom: 20px;
        flex-wrap: wrap;
      }

      .product-tab-button {
        appearance: none;
        border: 1px solid rgba(128, 149, 255, 0.35);
        background: rgba(18, 24, 44, 0.75);
        color: #f4f6ff;
        padding: 8px 16px;
        border-radius: 999px;
        font-size: 0.78rem;
        letter-spacing: 0.06em;
        text-transform: uppercase;
        cursor: pointer;
        transition: background 0.18s ease, color 0.18s ease, border 0.18s ease;
      }

      .product-tab-button.active {
        background: linear-gradient(135deg, rgba(119, 137, 255, 0.95), rgba(140, 99, 255, 0.95));
        border-color: transparent;
      }

      .product-panel {
        display: block;
      }

      .product-panel.hidden {
        display: none !important;
      }

      .product-body {
        display: flex;
        gap: 24px;
        align-items: flex-start;
        flex-wrap: nowrap;
      }

      .product-controls {
        flex: 1 1 300px;
        max-width: 340px;
        min-width: 260px;
        display: flex;
        flex-direction: column;
        gap: 18px;
      }

      .product-visual {
        flex: 2 1 480px;
        min-width: 0;
        display: flex;
        flex-direction: column;
        gap: 18px;
      }

      .product-visual.full-width {
        flex: 1 1 100%;
        max-width: 100%;
      }

      .projection-header {
        display: flex;
        flex-wrap: wrap;
        gap: 18px;
        align-items: flex-end;
        margin-bottom: 24px;
      }

      .secret-wrapper {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      .secret-label {
        font-size: 0.72rem;
        font-weight: 600;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: rgba(146, 165, 255, 0.8);
      }

      .secret-wrapper input {
        padding: 9px 12px;
        border-radius: 12px;
        border: 1px solid rgba(128, 149, 255, 0.35);
        background: rgba(18, 24, 44, 0.9);
        color: #f4f6ff;
      }

      .secret-wrapper input:focus {
        outline: none;
        border-color: rgba(150, 170, 255, 0.85);
        box-shadow: 0 0 0 2px rgba(150, 170, 255, 0.28);
      }

      .projection-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 18px;
        align-items: flex-end;
        justify-content: flex-end;
      }

      .projection-actions .projection-archetypes {
        flex: 0 0 auto;
      }

      .projection-actions .projection-shared-controls {
        flex: 0 0 auto;
      }

      .projection-title {
        flex: 1 1 260px;
        min-width: 240px;
        display: grid;
        gap: 6px;
      }

      .projection-title h1 {
        margin: 0;
        font-size: 1.6rem;
        font-weight: 600;
        color: #f9fbff;
      }

      .projection-title p {
        margin: 0;
        font-size: 0.92rem;
        line-height: 1.5;
        color: rgba(210, 219, 255, 0.78);
      }

      .projection-archetypes {
        display: flex;
        flex-direction: column;
        gap: 8px;
        min-width: 160px;
      }

      .projection-shared-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 18px;
        align-items: flex-end;
        flex: 1 1 340px;
      }

      .projection-shared-controls .control {
        flex: 1 1 200px;
        min-width: 180px;
      }

      .shared-card {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .control-section {
        display: flex;
        flex-direction: column;
        gap: 18px;
        margin-bottom: 24px;
        border: 1px solid rgba(120, 143, 255, 0.15);
        border-radius: 16px;
        padding: 18px 16px 20px;
        background: rgba(18, 24, 44, 0.45);
      }

      .section-heading {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .section-title {
        margin: 0;
        font-size: 1rem;
        font-weight: 600;
        color: #e9edff;
      }

      .section-subtitle {
        font-size: 0.78rem;
        color: rgba(182, 196, 255, 0.82);
        text-transform: uppercase;
        letter-spacing: 0.08em;
      }

      .projection-summary {
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      }

      .chart-card h2 {
        margin: 0 0 12px;
        font-size: 1rem;
        font-weight: 600;
        color: #e6ecff;
      }

      .allocation-card {
        display: flex;
        flex-direction: column;
        gap: 20px;
      }

      .allocation-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 16px;
      }

      .allocation-header h2 {
        margin: 0;
        font-size: 1.1rem;
        font-weight: 600;
        color: #e6ecff;
      }

      .allocation-header p {
        margin: 6px 0 0;
        font-size: 0.8rem;
        color: rgba(190, 202, 255, 0.78);
      }

      .allocation-table-container {
        overflow-x: auto;
      }

      .allocation-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.85rem;
      }

      .allocation-table thead {
        background: rgba(30, 40, 72, 0.75);
      }

      .allocation-table th,
      .allocation-table td {
        padding: 10px 14px;
        border-bottom: 1px solid rgba(120, 143, 255, 0.15);
        text-align: left;
        color: rgba(220, 226, 255, 0.9);
      }

      .allocation-table td.numeric {
        text-align: right;
      }

      .allocation-table tr.allocation-section td {
        font-weight: 600;
        color: #fdfdff;
        background: rgba(30, 40, 72, 0.45);
      }

      .allocation-table tr.allocation-total td {
        font-weight: 600;
        color: #ffffff;
        border-top: 1px solid rgba(120, 143, 255, 0.35);
      }
      .control-panel h1 {
        font-size: 1.6rem;
        font-weight: 600;
        margin: 0 0 8px;
        color: #f9fbff;
      }

      .control-panel p {
        margin: 0;
        font-size: 0.92rem;
        line-height: 1.5;
        color: rgba(210, 219, 255, 0.78);
      }

      .controls {
        display: flex;
        flex-direction: column;
        gap: 22px;
      }

      .control {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .control-label {
        text-transform: uppercase;
        letter-spacing: 0.08em;
        font-size: 0.75rem;
        color: #92a5ff;
        font-weight: 600;
      }

      .control input[type="range"] {
        appearance: none;
        width: 100%;
        height: 6px;
        border-radius: 999px;
        background: linear-gradient(90deg, rgba(74, 99, 255, 0.3), rgba(138, 101, 255, 0.65));
        outline: none;
      }

      .control input[type="range"]::-webkit-slider-thumb {
        appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #8097ff;
        border: 2px solid rgba(255, 255, 255, 0.65);
        cursor: pointer;
        box-shadow: 0 0 0 6px rgba(128, 151, 255, 0.16);
      }

      .control input[type="range"]::-moz-range-thumb {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #8097ff;
        border: 2px solid rgba(255, 255, 255, 0.65);
        cursor: pointer;
        box-shadow: 0 0 0 6px rgba(128, 151, 255, 0.16);
      }

      .value-input {
        width: 140px;
        padding: 9px 12px;
        border-radius: 12px;
        border: 1px solid rgba(128, 149, 255, 0.35);
        background: rgba(22, 28, 48, 0.85);
        color: #f4f6ff;
        font-size: 0.92rem;
        font-variant-numeric: tabular-nums;
        align-self: flex-start;
      }

      .value-input:focus {
        outline: none;
        border-color: rgba(150, 170, 255, 0.85);
        box-shadow: 0 0 0 2px rgba(150, 170, 255, 0.28);
      }

      .size-scale {
        display: flex;
        justify-content: space-between;
        gap: 4px;
        font-size: 0.68rem;
        letter-spacing: 0.05em;
        color: rgba(180, 192, 255, 0.45);
        text-transform: uppercase;
        padding-top: 2px;
      }

      .size-scale span {
        flex: 1;
        text-align: center;
        position: relative;
        padding-top: 12px;
      }

      .size-scale span::before {
        content: "";
        position: absolute;
        top: 4px;
        left: 50%;
        transform: translateX(-50%);
        width: 2px;
        height: 6px;
        background: rgba(138, 158, 255, 0.25);
        border-radius: 999px;
      }

      .size-scale span.active {
        color: #f0f3ff;
        font-weight: 600;
      }

      .size-scale span.active::before {
        height: 10px;
        background: rgba(140, 160, 255, 0.9);
      }

      .color-panel {
        display: grid;
        gap: 14px;
        padding: 18px;
        background: rgba(20, 26, 48, 0.6);
        border: 1px solid rgba(118, 144, 255, 0.16);
        border-radius: 16px;
        width: 100%;
      }

      .color-panel h2 {
        margin: 0 0 4px;
        font-size: 1rem;
        font-weight: 600;
        color: #e6ecff;
      }

      .color-panel p {
        font-size: 0.78rem;
        color: rgba(190, 202, 255, 0.78);
        margin: 0;
      }

      .color-input-row {
        display: flex;
        gap: 10px;
      }

      .color-input-row input {
        flex: 1;
        padding: 9px 12px;
        border-radius: 12px;
        border: 1px solid rgba(128, 149, 255, 0.35);
        background: rgba(18, 24, 44, 0.9);
        color: #f4f6ff;
        font-size: 0.9rem;
      }

      .color-input-row input:focus {
        outline: none;
        border-color: rgba(150, 170, 255, 0.85);
        box-shadow: 0 0 0 2px rgba(150, 170, 255, 0.28);
      }

      .color-chip-list {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
      }

      .color-chip {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 6px 12px;
        border-radius: 999px;
        background: rgba(36, 44, 76, 0.8);
        border: 1px solid rgba(120, 143, 255, 0.24);
        font-size: 0.82rem;
      }

      .color-chip .swatch {
        width: 14px;
        height: 14px;
        border-radius: 50%;
        background: #ffffff;
        border: 1px solid rgba(0, 0, 0, 0.2);
      }

      .color-chip button {
        appearance: none;
        border: none;
        background: rgba(255, 255, 255, 0.12);
        color: #f4f6ff;
        border-radius: 8px;
        padding: 2px 6px;
        font-size: 0.7rem;
        cursor: pointer;
      }

      .color-chip button:hover {
        background: rgba(255, 109, 122, 0.5);
      }

      .color-note {
        font-size: 0.75rem;
        color: rgba(204, 214, 255, 0.78);
      }

      .color-note.warning {
        color: #ffb7c1;
      }

      .action-button {
        appearance: none;
        border: none;
        border-radius: 999px;
        padding: 10px 18px;
        font-size: 0.85rem;
        font-weight: 600;
        cursor: pointer;
        background: linear-gradient(135deg, rgba(119, 137, 255, 0.92), rgba(140, 99, 255, 0.92));
        color: #fff;
        transition: transform 0.15s ease, box-shadow 0.15s ease;
      }

      .action-button.is-pressed:not(:disabled) {
        transform: scale(0.98);
        box-shadow: 0 0 0 3px rgba(140, 99, 255, 0.45);
      }

      .action-button:disabled {
        background: rgba(90, 102, 150, 0.6);
        cursor: not-allowed;
        box-shadow: none;
      }

      .action-button:not(:disabled):hover {
        transform: translateY(-1px);
        box-shadow: 0 10px 24px rgba(92, 112, 240, 0.42);
      }

      .visual-panel {
        flex: 1;
        padding: 42px 48px;
        display: flex;
        flex-direction: column;
        gap: 28px;
      }

      .panel-card {
        background: rgba(17, 22, 38, 0.72);
        border-radius: 20px;
        border: 1px solid rgba(120, 143, 255, 0.18);
        padding: 28px 32px;
        box-shadow: 0 18px 45px rgba(0, 4, 20, 0.38);
      }

      .summary-grid {
        display: grid;
        gap: 22px;
        grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      }

      .metric {
        display: grid;
        gap: 6px;
      }

      .metric span {
        text-transform: uppercase;
        letter-spacing: 0.08em;
        font-size: 0.72rem;
        color: rgba(160, 182, 255, 0.82);
      }

      .metric strong {
        font-size: 1.65rem;
        font-weight: 600;
        color: #fdfdff;
        font-variant-numeric: tabular-nums;
      }

      .metric small {
        font-size: 0.78rem;
        color: rgba(190, 204, 255, 0.7);
      }

      .chart-card {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 20px;
      }

      canvas {
        width: 100%;
        height: 400px;
        background: rgba(6, 10, 22, 0.85);
        border-radius: 16px;
        border: 1px solid rgba(120, 143, 255, 0.16);
      }

      .legend {
        display: grid;
        gap: 10px;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        font-size: 0.82rem;
        color: rgba(205, 215, 255, 0.85);
      }

      .legend div {
        background: rgba(20, 28, 48, 0.65);
        border-radius: 12px;
        padding: 10px 14px;
        border: 1px solid rgba(120, 143, 255, 0.12);
      }

      .color-table-card {
        display: flex;
        flex-direction: column;
        gap: 18px;
      }

      .color-table-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 18px;
      }

      .color-table-header h2 {
        margin: 0;
        font-size: 1.1rem;
        font-weight: 600;
        color: #e6ecff;
      }

      .color-table-header p {
        margin: 6px 0 0;
        font-size: 0.8rem;
        color: rgba(190, 202, 255, 0.78);
      }

      .color-table-container {
        overflow-x: auto;
      }

      .color-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.85rem;
      }

      .color-table thead {
        background: rgba(30, 40, 72, 0.75);
      }

      .color-table th,
      .color-table td {
        padding: 10px 14px;
        border-bottom: 1px solid rgba(120, 143, 255, 0.15);
        text-align: right;
        color: rgba(220, 226, 255, 0.9);
      }

      .color-table th:first-child,
      .color-table td:first-child {
        text-align: left;
      }

      .color-table tfoot td {
        font-weight: 600;
        color: #ffffff;
        border-top: 1px solid rgba(120, 143, 255, 0.35);
      }

      .empty-state {
        padding: 18px;
        background: rgba(26, 34, 60, 0.72);
        border-radius: 14px;
        border: 1px dashed rgba(120, 143, 255, 0.25);
        color: rgba(200, 210, 255, 0.75);
        text-align: center;
        font-size: 0.85rem;
      }

      .event-card {
        display: flex;
        flex-direction: column;
        gap: 24px;
      }

      .event-header {
        display: flex;
        flex-wrap: wrap;
        justify-content: space-between;
        align-items: flex-end;
        gap: 24px;
      }

      .event-source {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
      }

      .event-source input {
        flex: 1;
        min-width: 260px;
        padding: 10px 14px;
        border-radius: 12px;
        border: 1px solid rgba(128, 149, 255, 0.35);
        background: rgba(18, 24, 44, 0.9);
        color: #f4f6ff;
        font-size: 0.9rem;
      }

      .event-source input:focus {
        outline: none;
        border-color: rgba(150, 170, 255, 0.85);
        box-shadow: 0 0 0 2px rgba(150, 170, 255, 0.28);
      }

      .event-status {
        padding: 12px 16px;
        border-radius: 12px;
        background: rgba(26, 34, 60, 0.72);
        border: 1px solid rgba(120, 143, 255, 0.15);
        color: rgba(200, 210, 255, 0.88);
        font-size: 0.82rem;
      }

      .event-status[data-tone="error"] {
        border-color: rgba(255, 115, 148, 0.6);
        color: #ffb8c8;
      }

      .event-status[data-tone="success"] {
        border-color: rgba(132, 211, 166, 0.55);
        color: #bfffd5;
      }

      .event-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
      }

      .event-select {
        display: flex;
        flex-direction: column;
        gap: 8px;
        min-width: 220px;
      }

      .event-select label {
        letter-spacing: 0.08em;
        font-size: 0.75rem;
        color: #92a5ff;
        font-weight: 600;
        text-transform: none;
      }

      .event-select select {
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid rgba(128, 149, 255, 0.35);
        background: rgba(18, 24, 44, 0.9);
        color: #f4f6ff;
        font-size: 0.9rem;
      }

      .event-select select:focus {
        outline: none;
        border-color: rgba(150, 170, 255, 0.85);
        box-shadow: 0 0 0 2px rgba(150, 170, 255, 0.28);
      }

      .event-summary .metric strong {
        font-size: 1.4rem;
      }

      .event-chart-grid {
        display: grid;
        gap: 22px;
        grid-template-columns: repeat(auto-fit, minmax(360px, 1fr));
      }

      .event-chart-card {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .event-chart-card h3 {
        margin: 0;
        font-size: 1rem;
        font-weight: 600;
        color: #e6ecff;
      }

      .event-chart-card canvas {
        width: 100%;
        height: 320px;
        background: rgba(6, 10, 22, 0.85);
        border-radius: 16px;
        border: 1px solid rgba(120, 143, 255, 0.16);
      }

      .event-table {
        overflow-x: auto;
      }

      .event-table table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.85rem;
      }

      .event-table th,
      .event-table td {
        padding: 10px 14px;
        border-bottom: 1px solid rgba(120, 143, 255, 0.15);
        text-align: right;
        color: rgba(220, 226, 255, 0.9);
      }

      .event-table th:first-child,
      .event-table td:first-child {
        text-align: left;
      }

      .event-table td.event-empty {
        text-align: center;
        font-style: italic;
        color: rgba(204, 214, 255, 0.78);
        padding: 16px 18px;
      }

      .event-table tbody tr:hover {
        background: rgba(30, 40, 72, 0.5);
      }

      .event-table tfoot td {
        font-weight: 600;
        color: #ffffff;
        border-top: 1px solid rgba(120, 143, 255, 0.35);
      }

      .event-actions {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
        align-items: center;
      }

      .url-wrapper {
        display: flex;
        flex-direction: column;
        gap: 6px;
        position: relative;
        min-width: 260px;
      }

      .url-label {
        font-size: 0.72rem;
        font-weight: 600;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: rgba(146, 165, 255, 0.8);
      }

      .url-wrapper input[readonly] {
        pointer-events: none;
        opacity: 0.7;
        cursor: not-allowed;
      }

      .url-wrapper.locked::after {
        content: 'Locked';
        position: absolute;
        top: 46px;
        right: 12px;
        font-size: 0.7rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: rgba(204, 214, 255, 0.8);
      }

      .event-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 14px;
        font-size: 0.78rem;
        color: rgba(200, 210, 255, 0.78);
        margin-bottom: 12px;
      }

      .event-meta span {
        display: flex;
        gap: 6px;
        align-items: baseline;
      }

      .event-meta strong {
        color: #f4f6ff;
        font-weight: 600;
      }

      .event-actions button.secondary {
        background: rgba(80, 98, 180, 0.35);
        border: 1px solid rgba(128, 149, 255, 0.35);
      }

      .event-empty {
        padding: 20px;
        border-radius: 14px;
        border: 1px dashed rgba(120, 143, 255, 0.25);
        background: rgba(20, 28, 48, 0.5);
        color: rgba(200, 214, 255, 0.75);
        font-size: 0.85rem;
        text-align: center;
      }

      @media (max-width: 1080px) {
        .app {
          flex-direction: column;
        }

        .control-panel {
          width: 100%;
          border-right: none;
          border-bottom: 1px solid rgba(130, 155, 255, 0.18);
          flex-direction: column;
        }

        .visual-panel {
          padding: 32px 24px 48px;
        }

        .color-table-header {
          flex-direction: column;
          align-items: flex-start;
        }

        .product-body {
          flex-direction: column;
        }

        .product-controls,
        .product-visual {
          max-width: 100%;
          flex: 1 1 100%;
        }
      }
      }
    </style>
  </head>
  <body data-active-tab="projection">
    <div class="tab-bar">
      <button class="tab-button active" data-tab-button="projection">Size Curve</button>
      <button class="tab-button" data-tab-button="transactions">Square Transactions</button>
    </div>
    <div class="app">
            
    <main class="visual-panel">
        <section class="projection-header projection-only">
          <div class="projection-title">
            <h1>Collide Size Distribution Explorer</h1>
            <p>
              Apply an archetype or tune the skew-normal profile for hoodies and shirts independently. The
              size index runs from 4XL (0) to YM (9).
            </p>
          </div>
          <div class="projection-actions">
            <div class="projection-archetypes">
              <span class="archetype-label">Archetype</span>
              <div class="archetype-buttons">
                <button class="archetype-button" data-archetype="youth-hockey">Youth Hockey</button>
              </div>
            </div>
            <div class="projection-shared-controls">
              <div class="control" data-group="shared" data-key="teams">
                <label class="control-label" for="teams-range"># Teams</label>
                <input
                  id="teams-range"
                  type="range"
                  min="0"
                  max="250"
                  step="1"
                  value="24"
                />
                <input id="teams-input" class="value-input" type="number" step="1" min="0" max="250" value="24" />
              </div>
              <div class="control" data-group="shared" data-key="addon5APS">
                <label class="control-label" for="addon5-range">Add-On $5 APS</label>
                <input
                  id="addon5-range"
                  type="range"
                  min="0"
                  max="5"
                  step="0.01"
                  value="0.00"
                />
                <input id="addon5-input" class="value-input" type="number" step="0.01" min="0" max="5" value="0.00" />
              </div>
              <div class="control" data-group="shared" data-key="addon10APS">
                <label class="control-label" for="addon10-range">Add-On $10 APS</label>
                <input
                  id="addon10-range"
                  type="range"
                  min="0"
                  max="2"
                  step="0.01"
                  value="0.00"
                />
                <input id="addon10-input" class="value-input" type="number" step="0.01" min="0" max="2" value="0.00" />
              </div>
            </div>
          </div>
        </section>

        <section class="panel-card projection-only">
          <div class="summary-grid projection-summary">
            <div class="metric">
              <span>Teams</span>
              <strong data-metric="teams">24</strong>
            </div>
            <div class="metric">
              <span>Hoodie SPT</span>
              <strong data-metric="hoodieSpt">3.00</strong>
            </div>
            <div class="metric">
              <span>Shirt SPT</span>
              <strong data-metric="shirtSpt">1.00</strong>
            </div>
            <div class="metric">
              <span>Hoodies</span>
              <strong data-metric="hoodieTotal">72</strong>
            </div>
            <div class="metric">
              <span>Shirts</span>
              <strong data-metric="shirtTotal">24</strong>
            </div>
            <div class="metric">
              <span>Total Units</span>
              <strong data-metric="combinedTotal">96</strong>
            </div>
            <div class="metric">
              <span>Add-On $5</span>
              <strong data-metric="addon5Units">0.00</strong>
              <small>Expected Units</small>
            </div>
            <div class="metric">
              <span>Add-On $10</span>
              <strong data-metric="addon10Units">0.00</strong>
              <small>Expected Units</small>
            </div>
          </div>
        </section>

                <div class="product-tab-bar projection-only">
          <button class="product-tab-button active" data-product-tab-button="hoodie">Hoodies</button>
          <button class="product-tab-button" data-product-tab-button="shirt">Shirts</button>
          <button class="product-tab-button" data-product-tab-button="allocation">Allocation</button>
        </div>

        <section class="product-panel projection-only" data-product-tab="hoodie">
          <div class="product-body">
            <div class="product-controls">
              <section class="control-section" data-product="hoodie">
                <div class="section-heading">
                  <h2 class="section-title">Hoodie Curve</h2>
                  <span class="section-subtitle">Classic Hoodie</span>
                </div>
                <div class="controls">
                  <div class="control" data-group="hoodie" data-key="mean">
                    <label class="control-label" for="hoodie-mean-range">Mean</label>
                    <input id="hoodie-mean-range" type="range" min="0" max="9" step="0.01" value="4.50" />
                    <input id="hoodie-mean-input" class="value-input" type="number" step="0.01" min="0" max="9" value="4.50" />
                    <div class="size-scale" data-product="hoodie" aria-hidden="true">
                      <span data-index="0">4XL</span>
                      <span data-index="1">3XL</span>
                      <span data-index="2">2XL</span>
                      <span data-index="3">XL</span>
                      <span data-index="4">L</span>
                      <span data-index="5">M</span>
                      <span data-index="6">S</span>
                      <span data-index="7">YXL</span>
                      <span data-index="8">YL</span>
                      <span data-index="9">YM</span>
                    </div>
                  </div>
                  <div class="control" data-group="hoodie" data-key="sigma">
                    <label class="control-label" for="hoodie-sigma-range">Standard Deviation</label>
                    <input id="hoodie-sigma-range" type="range" min="0" max="5" step="0.01" value="2.00" />
                    <input id="hoodie-sigma-input" class="value-input" type="number" step="0.01" min="0" max="5" value="2.00" />
                  </div>
                  <div class="control" data-group="hoodie" data-key="skew">
                    <label class="control-label" for="hoodie-skew-range">Skew (alpha)</label>
                    <input id="hoodie-skew-range" type="range" min="-5" max="5" step="0.01" value="0.00" />
                    <input id="hoodie-skew-input" class="value-input" type="number" step="0.01" min="-5" max="5" value="0.00" />
                  </div>
                  <div class="control" data-group="hoodie" data-key="spt">
                    <label class="control-label" for="hoodie-spt-range">Hoodie SPT</label>
                    <input id="hoodie-spt-range" type="range" min="0" max="8" step="0.01" value="3.00" />
                    <input id="hoodie-spt-input" class="value-input" type="number" step="0.01" min="0" max="8" value="3.00" />
                  </div>
                </div>
              </section>
              <div class="color-panel hoodie-color-panel">
                <div>
                  <h2>Hoodie Color Mix</h2>
                  <p>Black holds 50% of production. Add up to three extras; the remainder splits evenly.</p>
                </div>
                <div class="color-input-row">
                  <input id="hoodie-color-entry" type="text" placeholder="Add color (e.g. Navy)" maxlength="32" />
                  <button id="hoodie-add-color" class="action-button" type="button">Add</button>
                </div>
                <div class="color-note" id="hoodie-color-note">Black accounts for 50% by default.</div>
                <div class="color-chip-list" id="hoodie-color-list"></div>
              </div>
            </div>
            <div class="product-visual">
              <section class="panel-card chart-card">
                <h2>Hoodie Size Curve</h2>
                <canvas id="hoodie-curve-chart" width="1100" height="360"></canvas>
                <div class="legend" id="hoodie-legend"></div>
              </section>
            </div>
          </div>
        </section>

        <section class="product-panel projection-only hidden" data-product-tab="shirt">
          <div class="product-body">
            <div class="product-controls">
              <section class="control-section" data-product="shirt">
                <div class="section-heading">
                  <h2 class="section-title">Shirt Curve</h2>
                  <span class="section-subtitle">Classic Shirt</span>
                </div>
                <div class="controls">
                  <div class="control" data-group="shirt" data-key="mean">
                    <label class="control-label" for="shirt-mean-range">Mean</label>
                    <input id="shirt-mean-range" type="range" min="0" max="9" step="0.01" value="4.00" />
                    <input id="shirt-mean-input" class="value-input" type="number" step="0.01" min="0" max="9" value="4.00" />
                    <div class="size-scale" data-product="shirt" aria-hidden="true">
                      <span data-index="0">4XL</span>
                      <span data-index="1">3XL</span>
                      <span data-index="2">2XL</span>
                      <span data-index="3">XL</span>
                      <span data-index="4">L</span>
                      <span data-index="5">M</span>
                      <span data-index="6">S</span>
                      <span data-index="7">YXL</span>
                      <span data-index="8">YL</span>
                      <span data-index="9">YM</span>
                    </div>
                  </div>
                  <div class="control" data-group="shirt" data-key="sigma">
                    <label class="control-label" for="shirt-sigma-range">Standard Deviation</label>
                    <input id="shirt-sigma-range" type="range" min="0" max="5" step="0.01" value="2.00" />
                    <input id="shirt-sigma-input" class="value-input" type="number" step="0.01" min="0" max="5" value="2.00" />
                  </div>
                  <div class="control" data-group="shirt" data-key="skew">
                    <label class="control-label" for="shirt-skew-range">Skew (alpha)</label>
                    <input id="shirt-skew-range" type="range" min="-5" max="5" step="0.01" value="0.00" />
                    <input id="shirt-skew-input" class="value-input" type="number" step="0.01" min="-5" max="5" value="0.00" />
                  </div>
                  <div class="control" data-group="shirt" data-key="spt">
                    <label class="control-label" for="shirt-spt-range">Shirt SPT</label>
                    <input id="shirt-spt-range" type="range" min="0" max="8" step="0.01" value="1.00" />
                    <input id="shirt-spt-input" class="value-input" type="number" step="0.01" min="0" max="8" value="1.00" />
                  </div>
                </div>
              </section>
              <div class="color-panel shirt-color-panel">
                <div>
                  <h2>Shirt Color Mix</h2>
                  <p>Colors split evenly across the listed options. Add as many as needed.</p>
                </div>
                <div class="color-input-row">
                  <input id="shirt-color-entry" type="text" placeholder="Add color (e.g. White)" maxlength="32" />
                  <button id="shirt-add-color" class="action-button" type="button">Add</button>
                </div>
                <div class="color-note" id="shirt-color-note">Add colors to split the total evenly.</div>
                <div class="color-chip-list" id="shirt-color-list"></div>
              </div>
            </div>
            <div class="product-visual">
              <section class="panel-card chart-card">
                <h2>Shirt Size Curve</h2>
                <canvas id="shirt-curve-chart" width="1100" height="360"></canvas>
                <div class="legend" id="shirt-legend"></div>
              </section>
            </div>
          </div>
        </section>

        <section class="product-panel projection-only hidden" data-product-tab="allocation">
          <div class="product-body">
            <div class="product-visual full-width">
              <section class="panel-card allocation-card">
                <div class="allocation-header">
                  <div>
                    <h2>Size &amp; Color Allocation</h2>
                    <p>Counts rounded to whole units per size and color.</p>
                  </div>
                  <button id="export-button" class="action-button" type="button">Export CSV</button>
                </div>
                <div class="allocation-table-container">
                  <table id="allocation-table" class="allocation-table">
                    <thead>
                      <tr>
                        <th>Product</th>
                        <th>Size</th>
                        <th>Total</th>
                        <th>Color</th>
                        <th>Units</th>
                      </tr>
                    </thead>
                    <tbody></tbody>
                  </table>
                </div>
              </section>
            </div>
          </div>
        </section>
<section class="panel-card event-card transactions-only">
          <div class="event-header">
            <div>
              <h2>Event Sales Explorer</h2>
              <p>Visualize actual hoodie, shirt, and add-on performance by event.</p>
            </div>
            <div class="event-actions">
              <div class="url-wrapper">
                <label class="url-label" for="event-source-url">Apps Script web app URL</label>
                <input id="event-source-url" type="url" placeholder="Paste URL and lock" />
              </div>
              <div class="secret-wrapper">
                <label class="secret-label" for="event-secret">Shared Secret</label>
                <input id="event-secret" type="password" placeholder="Enter secret" />
              </div>
              <button id="event-sync-button" class="action-button secondary" type="button">Sync Square</button>
              <button id="event-load-button" class="action-button" type="button">Fetch Data</button>
              <button id="event-load-sample" class="action-button secondary" type="button">Use Sample Data</button>
              <button id="event-lock-url" class="action-button secondary" type="button">Lock</button>
            </div>
          </div>
          <div id="event-status" class="event-status">Paste an Apps Script data URL or load the sample dataset.</div>
          <div class="event-meta">
            <span>Last Sync: <strong data-sync-timestamp>--</strong></span>
            <span>Last Fetch: <strong data-fetch-timestamp>--</strong></span>
          </div>
          <div class="event-controls">
            <div class="event-select">
              <label for="event-selector">Select Event</label>
              <select id="event-selector"></select>
            </div>
          </div>
          <div class="summary-grid event-summary">
            <div class="metric">
              <span>Classic Hoodies</span>
              <strong data-event-metric="hoodies">0</strong>
              <small>Units</small>
            </div>
            <div class="metric">
              <span>Classic Shirts</span>
              <strong data-event-metric="shirts">0</strong>
              <small>Units</small>
            </div>
            <div class="metric">
              <span>Add-On $5</span>
              <strong data-event-metric="addon5">0</strong>
              <small>Units</small>
            </div>
            <div class="metric">
              <span>Add-On $10</span>
              <strong data-event-metric="addon10">0</strong>
              <small>Units</small>
            </div>
            <div class="metric">
              <span>$5 APS</span>
              <strong data-event-metric="addon5APS">0.00</strong>
            </div>
            <div class="metric">
              <span>$10 APS</span>
              <strong data-event-metric="addon10APS">0.00</strong>
            </div>
          </div>
          <div class="event-chart-grid">
            <div class="event-chart-card">
              <h3>Classic Hoodies</h3>
              <canvas id="event-hoodie-chart" width="520" height="340"></canvas>
            </div>
            <div class="event-chart-card">
              <h3>Classic Shirts</h3>
              <canvas id="event-shirt-chart" width="520" height="340"></canvas>
            </div>
          </div>
          <div class="event-table">
            <table id="event-size-table">
              <thead>
                <tr>
                  <th>Size</th>
                  <th>Hoodies</th>
                  <th>Shirts</th>
                  <th>Total</th>
                </tr>
              </thead>
              <tbody></tbody>
              <tfoot>
                <tr>
                  <td>Total</td>
                  <td data-event-total="hoodies">0</td>
                  <td data-event-total="shirts">0</td>
                  <td data-event-total="combined">0</td>
                </tr>
              </tfoot>
            </table>
          </div>
        </section>

      </main>
    </div>

    <script>
      const SIZES = ["4XL", "3XL", "2XL", "XL", "L", "M", "S", "YXL", "YL", "YM"];
      const BLACK_ONLY_SIZE_INDICES = new Set([0, 1, 2]);

      function normalizeBaseUrl(rawUrl) {
        try {
          const parsed = new URL(rawUrl);
          parsed.searchParams.delete('action');
          parsed.searchParams.delete('secret');
          const base = parsed.origin + parsed.pathname;
          const search = parsed.searchParams.toString();
          return search ? `${base}?${search}` : base;
        } catch (error) {
          return rawUrl;
        }
      }

      function buildActionUrl(rawUrl, action, secret) {
        try {
          const parsed = new URL(rawUrl);
          if (action) {
            parsed.searchParams.set('action', action);
          } else {
            parsed.searchParams.delete('action');
          }
          if (secret) {
            parsed.searchParams.set('secret', secret);
          } else {
            parsed.searchParams.delete('secret');
          }
          return parsed.toString();
        } catch (error) {
          const separator = rawUrl.includes('?') ? '&' : '?';
          const params = [];
          if (action) params.push(`action=${encodeURIComponent(action)}`);
          if (secret) params.push(`secret=${encodeURIComponent(secret)}`);
          if (params.length === 0) {
            return rawUrl;
          }
          return `${rawUrl}${separator}${params.join('&')}`;
        }
      }

      function formatTimestamp(value) {
        if (!value) return '--';
        const date = value instanceof Date ? value : new Date(value);
        if (Number.isNaN(date.getTime())) return '--';
        return date.toLocaleString();
      }

      function updateSyncFetchDisplay() {
        if (summaryDisplays.syncTimestamp) {
          summaryDisplays.syncTimestamp.textContent = formatTimestamp(eventState.syncTimestamp);
        }
        if (summaryDisplays.fetchTimestamp) {
          summaryDisplays.fetchTimestamp.textContent = formatTimestamp(eventState.fetchTimestamp);
        }
      }

      const PRODUCTS = {
        hoodie: {
          key: 'hoodie',
          label: 'Classic Hoodie',
          prefix: 'hoodie',
          chartId: 'hoodie-curve-chart',
          legendId: 'hoodie-legend',
          colorConfig: {
            baseColors: ['Black'],
            extrasMax: 3,
            entryId: 'hoodie-color-entry',
            addButtonId: 'hoodie-add-color',
            listId: 'hoodie-color-list',
            noteId: 'hoodie-color-note',
            noteDefault: 'Black accounts for 50% by default.',
            noteMax: 'Maximum of three additional colors reached.'
          }
        },
        shirt: {
          key: 'shirt',
          label: 'Classic Shirt',
          prefix: 'shirt',
          chartId: 'shirt-curve-chart',
          legendId: 'shirt-legend',
          colorConfig: {
            baseColors: [],
            extrasMax: 12,
            entryId: 'shirt-color-entry',
            addButtonId: 'shirt-add-color',
            listId: 'shirt-color-list',
            noteId: 'shirt-color-note',
            noteDefault: 'Add colors to split the total evenly.',
            noteMax: 'Maximum color list reached.'
          }
        }
      };

      const ARCHETYPE_PRESETS = {
        'youth-hockey': {
          label: 'Youth Hockey',
          hoodie: { mean: 6.24, sigma: 1.53, skew: -0.80, spt: 3 },
          shirt: { mean: 7.66, sigma: 2.25, skew: -0.87, spt: 1 },
          shared: { addon5APS: 1.75, addon10APS: 0.5 }
        }
      };

      const APP_STORAGE_KEYS = {
        activeTab: 'collide:activeTab',
        urlLocked: 'collide:eventUrlLocked',
        archetype: 'collide:archetype',
        productTab: 'collide:productTab'
      };

      const CONTROL_CONFIG = {
        hoodie: {
          mean: { precision: 2, span: 9, absoluteMin: 0, absoluteMax: 9 },
          sigma: { precision: 2, span: 5, absoluteMin: 0.05, absoluteMax: 5 },
          skew: { precision: 2, span: 10, absoluteMin: -5, absoluteMax: 5 },
          spt: { precision: 2, span: 8, absoluteMin: 0, absoluteMax: 8 }
        },
        shirt: {
          mean: { precision: 2, span: 9, absoluteMin: 0, absoluteMax: 9 },
          sigma: { precision: 2, span: 5, absoluteMin: 0.05, absoluteMax: 5 },
          skew: { precision: 2, span: 10, absoluteMin: -5, absoluteMax: 5 },
          spt: { precision: 2, span: 8, absoluteMin: 0, absoluteMax: 8 }
        },
        shared: {
          teams: { precision: 0, span: 250, absoluteMin: 0, absoluteMax: 250 },
          addon5APS: { precision: 2, absoluteMin: 0, absoluteMax: 5 },
          addon10APS: { precision: 2, absoluteMin: 0, absoluteMax: 2 }
        }
      };

      const controlElements = {
        hoodie: {
          mean: {
            slider: document.getElementById('hoodie-mean-range'),
            input: document.getElementById('hoodie-mean-input')
          },
          sigma: {
            slider: document.getElementById('hoodie-sigma-range'),
            input: document.getElementById('hoodie-sigma-input')
          },
          skew: {
            slider: document.getElementById('hoodie-skew-range'),
            input: document.getElementById('hoodie-skew-input')
          },
          spt: {
            slider: document.getElementById('hoodie-spt-range'),
            input: document.getElementById('hoodie-spt-input')
          }
        },
        shirt: {
          mean: {
            slider: document.getElementById('shirt-mean-range'),
            input: document.getElementById('shirt-mean-input')
          },
          sigma: {
            slider: document.getElementById('shirt-sigma-range'),
            input: document.getElementById('shirt-sigma-input')
          },
          skew: {
            slider: document.getElementById('shirt-skew-range'),
            input: document.getElementById('shirt-skew-input')
          },
          spt: {
            slider: document.getElementById('shirt-spt-range'),
            input: document.getElementById('shirt-spt-input')
          }
        },
        shared: {
          teams: {
            slider: document.getElementById('teams-range'),
            input: document.getElementById('teams-input')
          },
          addon5APS: {
            slider: document.getElementById('addon5-range'),
            input: document.getElementById('addon5-input')
          },
          addon10APS: {
            slider: document.getElementById('addon10-range'),
            input: document.getElementById('addon10-input')
          }
        }
      };

      const sizeScaleElements = {
        hoodie: Array.from(document.querySelectorAll('.size-scale[data-product="hoodie"] span')),
        shirt: Array.from(document.querySelectorAll('.size-scale[data-product="shirt"] span'))
      };

      const summaryDisplays = {
        teams: document.querySelector('[data-metric="teams"]'),
        hoodieSpt: document.querySelector('[data-metric="hoodieSpt"]'),
        shirtSpt: document.querySelector('[data-metric="shirtSpt"]'),
        hoodieTotal: document.querySelector('[data-metric="hoodieTotal"]'),
        shirtTotal: document.querySelector('[data-metric="shirtTotal"]'),
        combinedTotal: document.querySelector('[data-metric="combinedTotal"]'),
        addon5Units: document.querySelector('[data-metric="addon5Units"]'),
        addon10Units: document.querySelector('[data-metric="addon10Units"]'),
        syncTimestamp: document.querySelector('[data-sync-timestamp]'),
        fetchTimestamp: document.querySelector('[data-fetch-timestamp]')
      };

      const eventState = {
        rawRows: [],
        events: [],
        selectedEventId: "",
        lastUpdated: null,
        urls: null,
        secret: '',
        syncTimestamp: null,
        fetchTimestamp: null
      };

      const eventLoadingState = {
        sync: false,
        fetch: false
      };

      const hoodieCurveCanvas = document.getElementById('hoodie-curve-chart');
      const shirtCurveCanvas = document.getElementById('shirt-curve-chart');
      const hoodieLegend = document.getElementById('hoodie-legend');
      const shirtLegend = document.getElementById('shirt-legend');
      const allocationTableBody = document.querySelector('#allocation-table tbody');
      const allocationExportButton = document.getElementById('export-button');
      const archetypeButtons = Array.from(document.querySelectorAll('.archetype-button'));
      const tabButtons = Array.from(document.querySelectorAll('[data-tab-button]'));
const productTabButtons = Array.from(document.querySelectorAll('[data-product-tab-button]'));
      const productPanels = Array.from(document.querySelectorAll('[data-product-tab]'));

      function setActiveProductTab(key, { persist = true } = {}) {
        const validKeys = productPanels.map((panel) => panel.dataset.productTab);
        const target = validKeys.includes(key) ? key : 'hoodie';
        productTabButtons.forEach((button) => {
          button.classList.toggle('active', button.dataset.productTabButton === target);
        });
        productPanels.forEach((panel) => {
          panel.classList.toggle('hidden', panel.dataset.productTab !== target);
        });
        if (persist) {
          safeWriteStorage(APP_STORAGE_KEYS.productTab, target);
        }
      }

      productTabButtons.forEach((button) => {
        button.addEventListener('click', () => {
          setActiveProductTab(button.dataset.productTabButton || 'hoodie');
        });
      });

            const projectionNodes = document.querySelectorAll('.projection-only');
      const transactionNodes = document.querySelectorAll('.transactions-only');

      let activeArchetypeKey = null;
      let currentAllocation = null;

      function setActiveTab(tab, { persist = true } = {}) {
        const target = tab === 'transactions' ? 'transactions' : 'projection';
        tabButtons.forEach((button) => {
          button.classList.toggle('active', button.dataset.tabButton === target);
        });
        projectionNodes.forEach((node) => {
          node.classList.toggle('hidden', target !== 'projection');
        });
        transactionNodes.forEach((node) => {
          node.classList.toggle('hidden', target !== 'transactions');
        });
        document.body.dataset.activeTab = target;
        if (persist) {
          safeWriteStorage(APP_STORAGE_KEYS.activeTab, target);
        }
      }

      tabButtons.forEach((button) => {
        button.addEventListener('click', () => {
          setActiveTab(button.dataset.tabButton || 'projection');
        });
      });


      function formatValue(value, precision) {
        return Number(value).toFixed(precision);
      }

      function updateSizeScale(productKey, mean) {
        const spans = sizeScaleElements[productKey];
        if (!spans || !spans.length) return;
        const clamped = Math.max(0, Math.min(SIZES.length - 1, Math.round(mean)));
        spans.forEach((span) => {
          const index = Number(span.dataset.index);
          span.classList.toggle('active', index === clamped);
        });
      }

      function ensureSliderRange(groupKey, key, value) {
        const groupConfig = CONTROL_CONFIG[groupKey];
        if (!groupConfig) return;
        const config = groupConfig[key];
        if (!config) return;
        const { slider } = controlElements[groupKey][key];
        if (!slider) return;
        const span = config.span;
        if (!span) return;
        let min = value - span / 2;
        let max = value + span / 2;
        if (config.absoluteMin !== undefined && min < config.absoluteMin) {
          min = config.absoluteMin;
          max = min + span;
        }
        if (config.absoluteMax !== undefined && max > config.absoluteMax) {
          max = config.absoluteMax;
          min = max - span;
          if (config.absoluteMin !== undefined && min < config.absoluteMin) {
            min = config.absoluteMin;
          }
        }
        slider.min = formatValue(min, config.precision);
        slider.max = formatValue(max, config.precision);
      }

      function setControlValue(groupKey, key, rawValue, { source = 'programmatic', silent = false } = {}) {
        const groupConfig = CONTROL_CONFIG[groupKey];
        const element = controlElements[groupKey] && controlElements[groupKey][key];
        if (!element) return;
        let value = rawValue;
        const config = groupConfig ? groupConfig[key] : undefined;
        if (config) {
          if (config.absoluteMin !== undefined && value < config.absoluteMin) {
            value = config.absoluteMin;
          }
          if (config.absoluteMax !== undefined && value > config.absoluteMax) {
            value = config.absoluteMax;
          }
          ensureSliderRange(groupKey, key, value);
        }
        if (element.slider && config) {
          element.slider.value = formatValue(value, config.precision);
        } else if (element.slider) {
          element.slider.value = value;
        }
        if (element.input) {
          const precision = config ? config.precision : 2;
          element.input.value = formatValue(value, precision);
        }
        if (groupKey === 'hoodie' && key === 'mean') {
          updateSizeScale('hoodie', value);
        }
        if (groupKey === 'shirt' && key === 'mean') {
          updateSizeScale('shirt', value);
        }
        if (!silent) {
          if (source !== 'archetype') {
            clearActiveArchetype();
          }
          recompute();
        }
      }

      function getNumericValue(element, fallback = 0) {
        if (!element) return fallback;
        const value = parseFloat(element.value);
        return Number.isFinite(value) ? value : fallback;
      }

      function clearActiveArchetype() {
        if (!activeArchetypeKey) return;
        archetypeButtons.forEach((button) => button.classList.remove('active'));
        activeArchetypeKey = null;
        safeWriteStorage(APP_STORAGE_KEYS.archetype, '');
      }

      function setActiveArchetype(key) {
        activeArchetypeKey = key;
        archetypeButtons.forEach((button) => {
          button.classList.toggle('active', button.dataset.archetype === key);
        });
        if (key) {
          safeWriteStorage(APP_STORAGE_KEYS.archetype, key);
        }
      }

      function applyArchetype(key) {
        const preset = ARCHETYPE_PRESETS[key];
        if (!preset) return;
        setActiveArchetype(key);
        const ops = { source: 'archetype', silent: true };
        setControlValue('hoodie', 'mean', preset.hoodie.mean, ops);
        setControlValue('hoodie', 'sigma', preset.hoodie.sigma, ops);
        setControlValue('hoodie', 'skew', preset.hoodie.skew, ops);
        setControlValue('hoodie', 'spt', preset.hoodie.spt, ops);
        setControlValue('shirt', 'mean', preset.shirt.mean, ops);
        setControlValue('shirt', 'sigma', preset.shirt.sigma, ops);
        setControlValue('shirt', 'skew', preset.shirt.skew, ops);
        setControlValue('shirt', 'spt', preset.shirt.spt, ops);
        setControlValue('shared', 'addon5APS', preset.shared.addon5APS, { source: 'archetype', silent: true });
        setControlValue('shared', 'addon10APS', preset.shared.addon10APS, { source: 'archetype', silent: true });
        recompute();
      }

      archetypeButtons.forEach((button) => {
        button.addEventListener('click', () => {
          const key = button.dataset.archetype;
          applyArchetype(key);
        });
      });

      function createColorManager(config) {
        const state = { extras: [] };
        const entry = document.getElementById(config.entryId);
        const addButton = document.getElementById(config.addButtonId);
        const list = document.getElementById(config.listId);
        const note = document.getElementById(config.noteId);

        function normalizeName(name) {
          return name.trim().replace(/\s+/g, ' ');
        }

        function updateNote(message, isWarning = false) {
          if (!note) return;
          if (message) {
            note.textContent = message;
          } else if (config.baseColors.length) {
            if (state.extras.length) {
              note.textContent = `Black is 50%. Remaining 50% split across ${state.extras.length} color(s).`;
            } else {
              note.textContent = config.noteDefault;
            }
          } else if (state.extras.length) {
            note.textContent = `Splitting evenly across ${state.extras.length} color(s).`;
          } else {
            note.textContent = config.noteDefault;
          }
          note.classList.toggle('warning', isWarning);
        }

        function renderChips() {
          if (!list) return;
          list.innerHTML = '';
          state.extras.forEach((color) => {
            const chip = document.createElement('span');
            chip.className = 'color-chip';
            const swatch = document.createElement('span');
            swatch.className = 'swatch';
            swatch.style.background = color;
            const label = document.createElement('span');
            label.textContent = color;
            const button = document.createElement('button');
            button.type = 'button';
            button.textContent = 'x';
            button.addEventListener('click', () => {
              state.extras = state.extras.filter((c) => c !== color);
              renderChips();
              updateNote();
              recompute();
            });
            chip.appendChild(swatch);
            chip.appendChild(label);
            chip.appendChild(button);
            list.appendChild(chip);
          });
        }

        function addColorFromInput() {
          if (!entry) return;
          const sanitized = normalizeName(entry.value || '');
          if (!sanitized) {
            updateNote('Enter a color name before adding.', true);
            return;
          }
          const exists = state.extras.some((color) => color.toLowerCase() === sanitized.toLowerCase());
          const baseExists = config.baseColors.some((color) => color.toLowerCase() === sanitized.toLowerCase());
          if (exists || baseExists) {
            updateNote('Color already added.', true);
            return;
          }
          if (state.extras.length >= config.extrasMax) {
            updateNote(config.noteMax, true);
            return;
          }
          state.extras.push(sanitized);
          entry.value = '';
          renderChips();
          updateNote();
          recompute();
        }

        if (addButton) {
          addButton.addEventListener('click', addColorFromInput);
        }
        if (entry) {
          entry.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
              event.preventDefault();
              addColorFromInput();
            }
          });
        }

        updateNote();
        renderChips();

        return {
          getNames() {
            return config.baseColors.concat(state.extras);
          },
          getWeights() {
            const names = this.getNames();
            if (!names.length) {
              return [];
            }
            if (config.baseColors.length) {
              if (state.extras.length === 0) {
                return [1];
              }
              const extraShare = 0.5 / state.extras.length;
              return [0.5, ...state.extras.map(() => extraShare)];
            }
            const weight = 1 / names.length;
            return names.map(() => weight);
          }
        };
      }

      const colorManagers = {
        hoodie: createColorManager(PRODUCTS.hoodie.colorConfig),
        shirt: createColorManager(PRODUCTS.shirt.colorConfig)
      };

      function erf(x) {
        const sign = x >= 0 ? 1 : -1;
        const absX = Math.abs(x);
        const t = 1 / (1 + 0.3275911 * absX);
        const a1 = 0.254829592;
        const a2 = -0.284496736;
        const a3 = 1.421413741;
        const a4 = -1.453152027;
        const a5 = 1.061405429;
        const poly = (((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t);
        const expTerm = Math.exp(-absX * absX);
        return sign * (1 - poly * expTerm);
      }

      const SQRT_TWO_PI = Math.sqrt(2 * Math.PI);
      const SQRT_TWO = Math.sqrt(2);

      function normalPdf(z) {
        return Math.exp(-0.5 * z * z) / SQRT_TWO_PI;
      }

      function normalCdf(z) {
        return 0.5 * (1 + erf(z / SQRT_TWO));
      }

      function skewNormalPdf(x, mean, sigma, alpha) {
        const z = (x - mean) / sigma;
        const base = (2 / sigma) * normalPdf(z);
        return base * normalCdf(alpha * z);
      }

      function probabilityForBin(index, mean, sigma, alpha) {
        const lower = index - 0.5;
        const upper = index + 0.5;
        const steps = 200;
        const h = (upper - lower) / steps;
        let sum = 0.5 * (skewNormalPdf(lower, mean, sigma, alpha) + skewNormalPdf(upper, mean, sigma, alpha));
        for (let i = 1; i < steps; i++) {
          const x = lower + i * h;
          sum += skewNormalPdf(x, mean, sigma, alpha);
        }
        return sum * h;
      }

      function drawHistogram(canvasEl, counts, { percentages = [], yLabel = 'units', colors, barRadius = 12 } = {}) {
        if (!canvasEl || !Array.isArray(counts) || counts.length === 0) {
          return;
        }
        const ctx = canvasEl.getContext('2d');
        if (!ctx) {
          return;
        }

        const width = canvasEl.width;
        const height = canvasEl.height;
        ctx.clearRect(0, 0, width, height);

        const margin = { top: 36, right: 40, bottom: 70, left: 72 };
        const chartWidth = width - margin.left - margin.right;
        const chartHeight = height - margin.top - margin.bottom;
        const originX = margin.left;
        const originY = height - margin.bottom;
        const maxValue = Math.max(...counts, 0);
        const scaleMax = maxValue > 0 ? maxValue : 1;
        const barSpacing = counts.length ? chartWidth / counts.length : 0;
        const barWidth = barSpacing * 0.62;

        ctx.strokeStyle = 'rgba(149, 171, 255, 0.35)';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(originX, margin.top - 8);
        ctx.lineTo(originX, originY);
        ctx.lineTo(width - margin.right + 10, originY);
        ctx.stroke();

        ctx.font = "13px 'Inter', 'Segoe UI', sans-serif";
        ctx.fillStyle = 'rgba(218, 225, 255, 0.88)';
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';

        const tickCount = 5;
        ctx.setLineDash([5, 8]);
        ctx.lineWidth = 1;
        ctx.strokeStyle = 'rgba(90, 113, 188, 0.22)';
        for (let i = 0; i <= tickCount; i += 1) {
          const value = (scaleMax / tickCount) * i;
          const y = originY - (value / scaleMax) * chartHeight;
          ctx.beginPath();
          ctx.moveTo(originX, y);
          ctx.lineTo(width - margin.right, y);
          ctx.stroke();
          ctx.fillText(`${Math.round(value)} ${yLabel}`, originX - 12, y);
        }
        ctx.setLineDash([]);

        counts.forEach((count, index) => {
          const barHeight = scaleMax > 0 ? (count / scaleMax) * chartHeight : 0;
          const x = originX + index * barSpacing + (barSpacing - barWidth) / 2;
          const y = originY - barHeight;

          if (barHeight > 0) {
            const gradient = ctx.createLinearGradient(x, y, x, originY);
            const topColor = colors && colors.from ? colors.from : 'rgba(111, 136, 255, 0.95)';
            const bottomColor = colors && colors.to ? colors.to : 'rgba(73, 94, 201, 0.82)';
            gradient.addColorStop(0, topColor);
            gradient.addColorStop(1, bottomColor);
            ctx.fillStyle = gradient;
            drawRoundedRect(ctx, x, y, barWidth, barHeight, barRadius);
          }

          const percent = percentages[index] || 0;
          const roundedCount = Number.isFinite(count) ? Math.round(count) : 0;
          const labelParts = [roundedCount.toLocaleString()];
          if (percent > 0) {
            labelParts.push(`(${(percent * 100).toFixed(1)}%)`);
          }
          const label = labelParts.join(' ');

          ctx.fillStyle = '#ffffff';
          ctx.font = "12px 'Inter', 'Segoe UI', sans-serif";
          ctx.textAlign = 'center';
          ctx.textBaseline = 'bottom';
          if (barHeight > 0) {
            ctx.fillText(label, x + barWidth / 2, y - 10);
          } else {
            ctx.fillText('0', x + barWidth / 2, originY - 10);
          }

          ctx.textBaseline = 'top';
          ctx.fillStyle = 'rgba(182, 196, 255, 0.85)';
          ctx.save();
          ctx.translate(x, originY + 18);
          ctx.rotate(-Math.PI / 18);
          ctx.fillText(SIZES[index], 0, 0);
          ctx.restore();
        });
      }

      function drawRoundedRect(ctx, x, y, width, height, radius) {
        const r = Math.min(radius, width / 2, height / 2);
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.lineTo(x + width - r, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + r);
        ctx.lineTo(x + width, y + height - r);
        ctx.quadraticCurveTo(x + width, y + height, x + width - r, y + height);
        ctx.lineTo(x + r, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - r);
        ctx.lineTo(x, y + r);
        ctx.quadraticCurveTo(x, y, x + r, y);
        ctx.closePath();
        ctx.fill();
      }

      function allocateCounts(probabilities, totalUnits) {
        if (totalUnits <= 0) {
          return probabilities.map(() => 0);
        }
        const targetTotal = Math.round(totalUnits);
        const rawCounts = probabilities.map((p) => p * totalUnits);
        const counts = rawCounts.map((value) => Math.floor(value));
        const fractionalParts = rawCounts.map((value, index) => ({
          index,
          fraction: value - Math.floor(value)
        }));

        let remainder = targetTotal - counts.reduce((acc, value) => acc + value, 0);

        if (remainder > 0) {
          const sorted = fractionalParts.slice().sort((a, b) => b.fraction - a.fraction);
          let idx = 0;
          while (remainder > 0 && sorted.length > 0) {
            const target = sorted[idx % sorted.length];
            counts[target.index] += 1;
            remainder -= 1;
            idx += 1;
          }
        } else if (remainder < 0) {
          const sorted = fractionalParts.slice().sort((a, b) => a.fraction - b.fraction);
          let idx = 0;
          while (remainder < 0 && sorted.length > 0) {
            const target = sorted[idx % sorted.length];
            if (counts[target.index] > 0) {
              counts[target.index] -= 1;
              remainder += 1;
            }
            idx += 1;
          }
        }

        return counts;
      }

      function readAddonValue(key) {
        const element = controlElements.shared[key];
        if (!element) {
          return 0;
        }
        if (element.slider) {
          const sliderValue = parseFloat(element.slider.value);
          if (Number.isFinite(sliderValue)) {
            return sliderValue;
          }
        }
        if (element.input) {
          const inputValue = parseFloat(element.input.value);
          if (Number.isFinite(inputValue)) {
            return inputValue;
          }
        }
        return 0;
      }

      function computeDistribution(mean, sigma, skew) {
        const probabilities = SIZES.map((_, index) => probabilityForBin(index, mean, sigma, skew));
        const total = probabilities.reduce((acc, value) => acc + value, 0);
        return probabilities.map((value) => (total > 0 ? value / total : 0));
      }

      function computeProductProjection(productKey, teams) {
        const controls = controlElements[productKey];
        const mean = parseFloat(controls.mean.slider.value);
        const sigma = parseFloat(controls.sigma.slider.value);
        const skew = parseFloat(controls.skew.slider.value);
        const spt = parseFloat(controls.spt.slider.value);
        updateSizeScale(productKey, mean);
        const distribution = computeDistribution(mean, sigma, skew);
        const totalUnits = spt * teams;
        const counts = allocateCounts(distribution, totalUnits);
        const total = counts.reduce((acc, value) => acc + value, 0);
        const percentages = counts.map((count) => (total > 0 ? count / total : 0));
        const rawAddons = {
          addon5: readAddonValue('addon5APS') * total,
          addon10: readAddonValue('addon10APS') * total
        };
        return {
          productKey,
          mean,
          sigma,
          skew,
          spt,
          distribution,
          totalUnits,
          counts,
          percentages,
          addons: rawAddons
        };
      }

      function allocateRowColors(total, weights, { lockFirst = false, sizeIndex } = {}) {
        if (total === 0 || weights.length === 0) {
          return weights.map(() => 0);
        }
        if (lockFirst && BLACK_ONLY_SIZE_INDICES.has(sizeIndex)) {
          return [total, ...weights.slice(1).map(() => 0)];
        }
        const raw = weights.map((w) => w * total);
        const counts = raw.map((value) => Math.round(value));
        let difference = total - counts.reduce((acc, value) => acc + value, 0);
        if (difference !== 0) {
          const adjustment = raw
            .map((value, index) => ({ index, remainder: value - Math.floor(value) }))
            .sort((a, b) => (difference > 0 ? b.remainder - a.remainder : a.remainder - b.remainder));
          let idx = 0;
          while (difference !== 0 && adjustment.length > 0) {
            const target = adjustment[idx % adjustment.length];
            if (difference > 0) {
              counts[target.index] += 1;
              difference -= 1;
            } else if (difference < 0 && counts[target.index] > 0) {
              counts[target.index] -= 1;
              difference += 1;
            }
            idx += 1;
          }
        }
        return counts;
      }

      function computeColorPlan(productKey, counts) {
        const product = PRODUCTS[productKey];
        const manager = colorManagers[productKey];
        const names = manager.getNames();
        const weights = manager.getWeights();
        const rows = counts.map((total, index) => {
          let breakdown = [];
          if (names.length) {
            const colorCounts = allocateRowColors(total, weights, {
              lockFirst: productKey === 'hoodie',
              sizeIndex: index
            });
            breakdown = names.map((name, colorIndex) => ({ name, value: colorCounts[colorIndex] || 0 }));
          }
          return {
            product: product.label,
            size: SIZES[index],
            index,
            total,
            colors: breakdown
          };
        });
        const colorTotals = names.map((name, idx) =>
          rows.reduce((acc, row) => acc + (row.colors[idx] ? row.colors[idx].value : 0), 0)
        );
        const grandTotal = counts.reduce((acc, value) => acc + value, 0);
        return {
          product: product.label,
          key: productKey,
          names,
          rows,
          colorTotals,
          grandTotal
        };
      }

      function renderLegend(legendElement, counts, percentages) {
        if (!legendElement) return;
        legendElement.innerHTML = '';
        counts.forEach((count, index) => {
          const percent = Math.round((percentages[index] || 0) * 100);
          const item = document.createElement('div');
          item.textContent = `${SIZES[index]}: ${count.toLocaleString()} units (${Number.isFinite(percent) ? percent : 0}%)`;
          legendElement.appendChild(item);
        });
      }

      function renderAllocationTable(bundle) {
        if (!allocationTableBody) return;
        allocationTableBody.innerHTML = '';
        const plans = bundle && bundle.plans ? bundle.plans : bundle;
        const addons = bundle && bundle.addons ? bundle.addons : null;
        ['hoodie', 'shirt'].forEach((productKey) => {
          const plan = plans && plans[productKey];
          if (!plan) return;

          const headerRow = document.createElement('tr');
          headerRow.className = 'allocation-section';
          const headerCell = document.createElement('td');
          headerCell.colSpan = 5;
          headerCell.textContent = plan.product;
          headerRow.appendChild(headerCell);
          allocationTableBody.appendChild(headerRow);

          plan.rows.forEach((row) => {
            const colors = row.colors.length ? row.colors : [{ name: '--', value: row.total }];
            colors.forEach((color, idx) => {
              const tr = document.createElement('tr');
              if (idx === 0) {
                const productCell = document.createElement('td');
                productCell.textContent = plan.product;
                productCell.rowSpan = colors.length;
                tr.appendChild(productCell);

                const sizeCell = document.createElement('td');
                sizeCell.textContent = row.size;
                sizeCell.rowSpan = colors.length;
                tr.appendChild(sizeCell);

                const totalCell = document.createElement('td');
                totalCell.className = 'numeric';
                totalCell.textContent = row.total.toLocaleString();
                totalCell.rowSpan = colors.length;
                tr.appendChild(totalCell);
              }

              const colorCell = document.createElement('td');
              colorCell.textContent = color.name;
              tr.appendChild(colorCell);

              const unitsCell = document.createElement('td');
              unitsCell.className = 'numeric';
              unitsCell.textContent = color.value ? formatNumber(color.value, { decimals: 2 }) : '--';
              tr.appendChild(unitsCell);

              allocationTableBody.appendChild(tr);
            });
          });

          const totalRow = document.createElement('tr');
          totalRow.className = 'allocation-total';
          const labelCell = document.createElement('td');
          labelCell.colSpan = 2;
          labelCell.textContent = `${plan.product} Total`;
          totalRow.appendChild(labelCell);

          const totalValueCell = document.createElement('td');
          totalValueCell.className = 'numeric';
          totalValueCell.textContent = plan.grandTotal.toLocaleString();
          totalRow.appendChild(totalValueCell);

          const spacerCell = document.createElement('td');
          spacerCell.textContent = '';
          totalRow.appendChild(spacerCell);

          const colorTotalCell = document.createElement('td');
          colorTotalCell.className = 'numeric';
          colorTotalCell.textContent = plan.grandTotal.toLocaleString();
          totalRow.appendChild(colorTotalCell);

          allocationTableBody.appendChild(totalRow);
        });

        if (addons) {
          const addOnHeader = document.createElement('tr');
          addOnHeader.className = 'allocation-section';
          const headerCell = document.createElement('td');
          headerCell.colSpan = 5;
          headerCell.textContent = 'Add-Ons';
          addOnHeader.appendChild(headerCell);
          allocationTableBody.appendChild(addOnHeader);

          const addOnRows = [
            { label: 'Add-On $5', value: addons.addon5 || 0 },
            { label: 'Add-On $10', value: addons.addon10 || 0 }
          ];
          addOnRows.forEach((entry) => {
            const tr = document.createElement('tr');
            const productCell = document.createElement('td');
            productCell.textContent = entry.label;
            tr.appendChild(productCell);

            const sizeCell = document.createElement('td');
            sizeCell.textContent = '--';
            tr.appendChild(sizeCell);

            const totalCell = document.createElement('td');
            totalCell.className = 'numeric';
            totalCell.textContent = formatNumber(entry.value, { decimals: 2 });
            tr.appendChild(totalCell);

            const colorCell = document.createElement('td');
            colorCell.textContent = '--';
            tr.appendChild(colorCell);

            const unitsCell = document.createElement('td');
            unitsCell.className = 'numeric';
            unitsCell.textContent = formatNumber(entry.value, { decimals: 2 });
            tr.appendChild(unitsCell);

            allocationTableBody.appendChild(tr);
          });

          const addOnTotal = (addons.addon5 || 0) + (addons.addon10 || 0);
          const totalRow = document.createElement('tr');
          totalRow.className = 'allocation-total';
          const labelCell = document.createElement('td');
          labelCell.colSpan = 2;
          labelCell.textContent = 'Add-Ons Total';
          totalRow.appendChild(labelCell);

          const totalValueCell = document.createElement('td');
          totalValueCell.className = 'numeric';
          totalValueCell.textContent = formatNumber(addOnTotal, { decimals: 2 });
          totalRow.appendChild(totalValueCell);

          const spacerCell = document.createElement('td');
          spacerCell.textContent = '';
          totalRow.appendChild(spacerCell);

          const colorTotalCell = document.createElement('td');
          colorTotalCell.className = 'numeric';
          colorTotalCell.textContent = '--';
          totalRow.appendChild(colorTotalCell);

          allocationTableBody.appendChild(totalRow);
        }
      }

      function buildCsv(bundle) {
        const header = ['Product', 'Size', 'Total', 'Color', 'Units'];
        const rows = [];
        const plans = bundle && bundle.plans ? bundle.plans : bundle;
        const addons = bundle && bundle.addons ? bundle.addons : null;
        ['hoodie', 'shirt'].forEach((productKey) => {
          const plan = plans && plans[productKey];
          if (!plan) return;
          plan.rows.forEach((row) => {
            const colors = row.colors.length ? row.colors : [{ name: '--', value: row.total }];
            colors.forEach((color, idx) => {
              rows.push([
                plan.product,
                idx === 0 ? row.size : '',
                idx === 0 ? row.total : '',
                color.name,
                color.value
              ]);
            });
          });
          rows.push([`${plan.product} Total`, '', plan.grandTotal, '', plan.grandTotal]);
        });
        if (addons) {
          const add5 = addons.addon5 || 0;
          const add10 = addons.addon10 || 0;
          const addOnTotal = add5 + add10;
          rows.push(['Add-On $5', '--', formatNumber(add5, { decimals: 2 }), '--', formatNumber(add5, { decimals: 2 })]);
          rows.push(['Add-On $10', '--', formatNumber(add10, { decimals: 2 }), '--', formatNumber(add10, { decimals: 2 })]);
          rows.push(['Add-Ons Total', '--', formatNumber(addOnTotal, { decimals: 2 }), '--', formatNumber(addOnTotal, { decimals: 2 })]);
        }
        const escape = (value) => {
          const str = String(value === undefined ? '' : value);
          if (/[",\n]/.test(str)) {
            return `"${str.replace(/"/g, '""')}"`;
          }
          return str;
        };
        return [header, ...rows].map((row) => row.map(escape).join(',')).join('\n');
      }

      function recompute() {
        const teams = parseFloat(controlElements.shared.teams.slider.value);
        const addon5APS = readAddonValue('addon5APS');
        const addon10APS = readAddonValue('addon10APS');

        const hoodieProjection = computeProductProjection('hoodie', teams);
        const shirtProjection = computeProductProjection('shirt', teams);

        const hoodieTotal = hoodieProjection.counts.reduce((acc, value) => acc + value, 0);
        const shirtTotal = shirtProjection.counts.reduce((acc, value) => acc + value, 0);
        const combinedTotal = hoodieTotal + shirtTotal;
        const addon5Units = addon5APS * combinedTotal;
        const addon10Units = addon10APS * combinedTotal;

        summaryDisplays.teams.textContent = teams.toLocaleString();
        summaryDisplays.hoodieSpt.textContent = formatValue(hoodieProjection.spt, CONTROL_CONFIG.hoodie.spt.precision);
        summaryDisplays.shirtSpt.textContent = formatValue(shirtProjection.spt, CONTROL_CONFIG.shirt.spt.precision);
        summaryDisplays.hoodieTotal.textContent = hoodieTotal.toLocaleString();
        summaryDisplays.shirtTotal.textContent = shirtTotal.toLocaleString();
        summaryDisplays.combinedTotal.textContent = combinedTotal.toLocaleString();
        summaryDisplays.addon5Units.textContent = formatNumber(addon5Units, { decimals: 2 });
        summaryDisplays.addon10Units.textContent = formatNumber(addon10Units, { decimals: 2 });

        hoodieProjection.addons = {
          addon5: addon5Units * (hoodieTotal / (combinedTotal || 1)),
          addon10: addon10Units * (hoodieTotal / (combinedTotal || 1))
        };
        shirtProjection.addons = {
          addon5: addon5Units * (shirtTotal / (combinedTotal || 1)),
          addon10: addon10Units * (shirtTotal / (combinedTotal || 1))
        };

        drawHistogram(
          hoodieCurveCanvas,
          hoodieProjection.counts,
          {
            percentages: hoodieProjection.percentages,
            yLabel: 'units',
            colors: { from: 'rgba(111, 136, 255, 0.95)', to: 'rgba(73, 94, 201, 0.82)' }
          }
        );
        drawHistogram(
          shirtCurveCanvas,
          shirtProjection.counts,
          {
            percentages: shirtProjection.percentages,
            yLabel: 'units',
            colors: { from: 'rgba(255, 166, 133, 0.9)', to: 'rgba(232, 112, 134, 0.82)' }
          }
        );

        renderLegend(hoodieLegend, hoodieProjection.counts, hoodieProjection.percentages);
        renderLegend(shirtLegend, shirtProjection.counts, shirtProjection.percentages);

        const allocationPlans = {
          hoodie: computeColorPlan('hoodie', hoodieProjection.counts),
          shirt: computeColorPlan('shirt', shirtProjection.counts)
        };
        const allocationBundle = {
          plans: allocationPlans,
          addons: { addon5: addon5Units, addon10: addon10Units },
          syncTimestamp: eventState.syncTimestamp || null,
          fetchTimestamp: new Date(),
          urls: eventState.urls || null
        };
        currentAllocation = allocationBundle;
        renderAllocationTable(allocationBundle);
      }

      function setupControlHandlers() {
        ['hoodie', 'shirt'].forEach((group) => {
          Object.keys(controlElements[group]).forEach((key) => {
            const { slider, input } = controlElements[group][key];
            if (slider) {
              slider.addEventListener('input', () => {
                const value = parseFloat(slider.value);
                if (!Number.isFinite(value)) return;
                setControlValue(group, key, value, { source: 'slider' });
              });
              const initial = parseFloat(slider.value);
              if (Number.isFinite(initial)) {
                setControlValue(group, key, initial, { silent: true });
              }
            }
            if (input) {
              input.addEventListener('input', () => {
                const value = parseFloat(input.value);
                if (!Number.isFinite(value)) return;
                setControlValue(group, key, value, { source: 'input', silent: true });
              });
              input.addEventListener('change', () => {
                const value = parseFloat(input.value);
                if (Number.isFinite(value)) {
                  setControlValue(group, key, value, { source: 'input' });
                }
              });
            }
          });
        });

        ['teams', 'addon5APS', 'addon10APS'].forEach((key) => {
          const control = controlElements.shared[key];
          if (!control) return;
          const { slider, input } = control;
          if (slider) {
            slider.addEventListener('input', () => {
              const value = parseFloat(slider.value);
              if (!Number.isFinite(value)) return;
              setControlValue('shared', key, value, { source: 'slider' });
            });
            const initial = parseFloat(slider.value);
            if (Number.isFinite(initial)) {
              setControlValue('shared', key, initial, { silent: true });
            }
          }
          if (input) {
            input.addEventListener('input', () => {
              const value = parseFloat(input.value);
              if (!Number.isFinite(value)) return;
              setControlValue('shared', key, value, { source: 'input', silent: true });
            });
            input.addEventListener('change', () => {
              const value = parseFloat(input.value);
              if (Number.isFinite(value)) {
                setControlValue('shared', key, value, { source: 'input' });
              }
            });
          }
        });
      }

      allocationExportButton.addEventListener('click', () => {
        if (!currentAllocation) {
          return;
        }
        const csv = buildCsv(currentAllocation);
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        const timestamp = new Date().toISOString().slice(0, 10);
        link.download = `collide_allocation_${timestamp}.csv`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        setTimeout(() => URL.revokeObjectURL(url), 1000);
      });

      function initializeProjection() {
        setupControlHandlers();

        const savedProductTab = safeReadStorage(APP_STORAGE_KEYS.productTab);
        setActiveProductTab(savedProductTab || 'hoodie', { persist: false });

        const savedTab = safeReadStorage(APP_STORAGE_KEYS.activeTab);
        if (savedTab) {
          setActiveTab(savedTab, { persist: false });
        } else {
          setActiveTab('projection', { persist: false });
        }

        const savedArchetype = safeReadStorage(APP_STORAGE_KEYS.archetype);
        if (savedArchetype && ARCHETYPE_PRESETS[savedArchetype]) {
          applyArchetype(savedArchetype);
        } else {
          recompute();
        }
      }

      initializeProjection();
      const eventElements = {
        sourceInput: document.getElementById("event-source-url"),
        secretInput: document.getElementById("event-secret"),
        loadButton: document.getElementById("event-load-button"),
        syncButton: document.getElementById("event-sync-button"),
        sampleButton: document.getElementById("event-load-sample"),
        lockButton: document.getElementById("event-lock-url"),
        status: document.getElementById("event-status"),
        eventSelect: document.getElementById("event-selector"),
        urlWrapper: document.querySelector('.url-wrapper'),
        hoodieCanvas: document.getElementById("event-hoodie-chart"),
        shirtCanvas: document.getElementById("event-shirt-chart"),
        tableBody: document.querySelector("#event-size-table tbody"),
        metricDisplays: {
          hoodies: document.querySelector('[data-event-metric="hoodies"]'),
          shirts: document.querySelector('[data-event-metric="shirts"]'),
          addon5: document.querySelector('[data-event-metric="addon5"]'),
          addon10: document.querySelector('[data-event-metric="addon10"]'),
          addon5APS: document.querySelector('[data-event-metric="addon5APS"]'),
          addon10APS: document.querySelector('[data-event-metric="addon10APS"]')
        },
        totalDisplays: {
          hoodies: document.querySelector('[data-event-total="hoodies"]'),
          shirts: document.querySelector('[data-event-total="shirts"]'),
          combined: document.querySelector('[data-event-total="combined"]')
        }
      };

      updateEventLoadingUi();

      function flashButton(button, { duration = 200 } = {}) {
        if (!button) {
          return;
        }
        button.classList.add('is-pressed');
        window.setTimeout(() => {
          button.classList.remove('is-pressed');
        }, duration);
      }

      function recomputeEventUrls() {
        if (!eventElements.sourceInput) {
          eventState.urls = null;
          return null;
        }
        const raw = eventElements.sourceInput.value ? eventElements.sourceInput.value.trim() : '';
        if (!raw) {
          eventState.urls = null;
          return null;
        }
        const base = normalizeBaseUrl(raw);
        if (raw !== base) {
          eventElements.sourceInput.value = base;
        }
        const secret = (eventState.secret || '').trim();
        eventState.urls = {
          base,
          sync: buildActionUrl(base, 'sync', secret),
          fetch: buildActionUrl(base, 'fetch', secret)
        };
        safeWriteStorage(EVENT_STORAGE_KEYS.source, base);
        return eventState.urls;
      }

      function getActionUrl(action) {
        const urls = recomputeEventUrls();
        if (!urls) {
          return '';
        }
        if (action === 'sync') {
          return urls.sync;
        }
        if (action === 'fetch') {
          return urls.fetch;
        }
        return urls.base;
      }

      function setSecretValue(value, { persist = true } = {}) {
        const trimmed = value ? value.trim() : '';
        eventState.secret = trimmed;
        if (persist) {
          safeWriteStorage(EVENT_STORAGE_KEYS.secret, trimmed);
        }
        eventState.urls = null;
        if (trimmed) {
          recomputeEventUrls();
        }
        return trimmed;
      }

      function ensureSecretProvided() {
        let secret = (eventState.secret || '').trim();
        if (!secret && eventElements.secretInput) {
          secret = setSecretValue(eventElements.secretInput.value, { persist: true });
        }
        if (secret) {
          return true;
        }
        setEventStatus('Enter the shared secret before continuing.', 'error');
        if (eventElements.secretInput) {
          eventElements.secretInput.focus();
        }
        return false;
      }

      function setUrlLocked(locked) {
        if (!eventElements.sourceInput) {
          return;
        }
        eventElements.sourceInput.readOnly = locked;
        if (locked) {
          eventElements.sourceInput.blur();
        }
        if (eventElements.urlWrapper) {
          eventElements.urlWrapper.classList.toggle('locked', locked);
        }
        if (eventElements.lockButton) {
          eventElements.lockButton.textContent = locked ? 'Unlock URL' : 'Lock URL';
        }
        if (locked) {
          recomputeEventUrls();
          safeWriteStorage(APP_STORAGE_KEYS.urlLocked, '1');
          setEventStatus('URL locked. Use Sync or Fetch when you are ready.', 'info');
        } else {
          eventState.urls = null;
          safeWriteStorage(APP_STORAGE_KEYS.urlLocked, '');
          setEventStatus('URL unlocked. You can paste a new Apps Script link.', 'info');
        }
      }

      if (eventElements.lockButton) {
        eventElements.lockButton.addEventListener('click', () => {
          flashButton(eventElements.lockButton);
          const isLocked = Boolean(eventElements.sourceInput && eventElements.sourceInput.readOnly);
          if (!isLocked) {
            const value = eventElements.sourceInput ? eventElements.sourceInput.value.trim() : '';
            if (!value) {
              setEventStatus('Enter the Apps Script web app URL before locking.', 'error');
              return;
            }
          }
          setUrlLocked(!isLocked);
        });
      }

      const EVENT_STORAGE_KEYS = {
        source: "collide:eventSource",
        eventId: "collide:eventId",
        secret: "collide:eventSecret"
      };

      // Column aliases for Square Transactions feed.
      const EVENT_FIELD_HINTS = {
        eventName: ["event", "event name", "event_title", "event label", "category"],
        eventKey: ["event id", "event identifier", "event key", "event code", "event", "category"],
        category: ["event category", "archetype", "event type", "series"],
        product: ["item", "item name", "product", "product name", "line item"],
        variation: ["variation", "variation name", "option", "option name", "sku", "price point name"],
        size: ["size", "size name", "size label", "size option", "modifiers applied"],
        quantity: ["quantity", "qty", "units", "count"],
        timestamp: ["timestamp", "sale timestamp", "created at", "sale time", "transaction time"],
        date: ["date"],
        time: ["time"],
        timeZone: ["time zone", "timezone"],
        venue: ["venue", "location", "rink", "city"]
      };

      const PRODUCT_KEYWORDS = {
        hoodie: ["classic hoodie"],
        shirt: ["classic shirt"],
        addon5: ["add on $5", "add-on $5", "add-on 5", "add-ons $5", "addon $5", "addon 5"],
        addon10: ["add on $10", "add-on $10", "add-on 10", "add-ons $10", "addon $10", "addon 10"]
      };


      const SIZE_ALIASES = {
        'extra large': 'XL',
        'adult extra large': 'XL',
        'xl': 'XL',
        'large': 'L',
        'adult large': 'L',
        'medium': 'M',
        'adult medium': 'M',
        'small': 'S',
        'adult small': 'S',
        'youth extra large': 'YXL',
        'yxl': 'YXL',
        'youth large': 'YL',
        'yl': 'YL',
        'youth medium': 'YM',
        'ym': 'YM'
      };
      const SIZE_SYNONYMS = {
        "4xl": "4XL",
        "xxxxl": "4XL",
        "3xl": "3XL",
        "xxxl": "3XL",
        "2xl": "2XL",
        "xxl": "2XL",
        "xl": "XL",
        "extra large": "XL",
        "adult extra large": "XL",
        "large": "L",
        "adult large": "L",
        "l": "L",
        "medium": "M",
        "adult medium": "M",
        "m": "M",
        "small": "S",
        "adult small": "S",
        "s": "S",
        "yxl": "YXL",
        "youth extra large": "YXL",
        "yl": "YL",
        "youth large": "YL",
        "ym": "YM",
        "youth medium": "YM"
      };

      const SAMPLE_EVENT_DATA = [
        {
          Date: "2024-02-16",
          Time: "10:35:00",
          "Time Zone": "America/Toronto",
          Category: "Frostbite Cup",
          Item: "Classic Hoodie",
          Qty: 3,
          "Price Point Name": "Black",
          SKU: "HOOD-BLK-4XL",
          "Modifiers Applied": "Adult 4XL",
          "Gross Sales": 225,
          Discounts: 0,
          "Net Sales": 225,
          Tax: 0
        },
        {
          Date: "2024-02-16",
          Time: "12:10:00",
          "Time Zone": "America/Toronto",
          Category: "Frostbite Cup",
          Item: "Classic Hoodie",
          Qty: 14,
          "Price Point Name": "Black",
          SKU: "HOOD-BLK-XL",
          "Modifiers Applied": "Adult XL",
          "Gross Sales": 1050,
          Discounts: 0,
          "Net Sales": 1050,
          Tax: 0
        },
        {
          Date: "2024-02-16",
          Time: "13:20:00",
          "Time Zone": "America/Toronto",
          Category: "Frostbite Cup",
          Item: "Classic Hoodie",
          Qty: 20,
          "Price Point Name": "Navy",
          SKU: "HOOD-NV-L",
          "Modifiers Applied": "Adult L",
          "Gross Sales": 1500,
          Discounts: 0,
          "Net Sales": 1500,
          Tax: 0
        },
        {
          Date: "2024-02-16",
          Time: "14:10:00",
          "Time Zone": "America/Toronto",
          Category: "Frostbite Cup",
          Item: "Classic Shirt",
          Qty: 18,
          "Price Point Name": "White",
          SKU: "SHRT-WHT-M",
          "Modifiers Applied": "Adult M",
          "Gross Sales": 450,
          Discounts: 0,
          "Net Sales": 450,
          Tax: 0
        },
        {
          Date: "2024-02-16",
          Time: "15:05:00",
          "Time Zone": "America/Toronto",
          Category: "Frostbite Cup",
          Item: "Classic Shirt",
          Qty: 9,
          "Price Point Name": "White",
          SKU: "SHRT-WHT-YL",
          "Modifiers Applied": "Youth Large",
          "Gross Sales": 225,
          Discounts: 0,
          "Net Sales": 225,
          Tax: 0
        },
        {
          Date: "2024-02-16",
          Time: "15:35:00",
          "Time Zone": "America/Toronto",
          Category: "Frostbite Cup",
          Item: "Add-On $5",
          Qty: 18,
          "Gross Sales": 90,
          Discounts: 0,
          "Net Sales": 90,
          Tax: 0
        },
        {
          Date: "2024-02-16",
          Time: "15:40:00",
          "Time Zone": "America/Toronto",
          Category: "Frostbite Cup",
          Item: "Add-On $10",
          Qty: 7,
          "Gross Sales": 70,
          Discounts: 0,
          "Net Sales": 70,
          Tax: 0
        },
        {
          Date: "2024-03-09",
          Time: "09:40:00",
          "Time Zone": "America/Toronto",
          Category: "Rinkside Classic",
          Item: "Classic Hoodie",
          Qty: 6,
          "Price Point Name": "Black",
          SKU: "HOOD-BLK-2XL",
          "Modifiers Applied": "Adult 2XL",
          "Gross Sales": 450,
          Discounts: 0,
          "Net Sales": 450,
          Tax: 0
        },
        {
          Date: "2024-03-09",
          Time: "10:15:00",
          "Time Zone": "America/Toronto",
          Category: "Rinkside Classic",
          Item: "Classic Hoodie",
          Qty: 12,
          "Price Point Name": "Grey",
          SKU: "HOOD-GRY-L",
          "Modifiers Applied": "Adult L",
          "Gross Sales": 900,
          Discounts: 0,
          "Net Sales": 900,
          Tax: 0
        },
        {
          Date: "2024-03-09",
          Time: "11:25:00",
          "Time Zone": "America/Toronto",
          Category: "Rinkside Classic",
          Item: "Classic Shirt",
          Qty: 10,
          "Price Point Name": "Grey",
          SKU: "SHRT-GRY-S",
          "Modifiers Applied": "Adult Small",
          "Gross Sales": 250,
          Discounts: 0,
          "Net Sales": 250,
          Tax: 0
        },
        {
          Date: "2024-03-09",
          Time: "12:05:00",
          "Time Zone": "America/Toronto",
          Category: "Rinkside Classic",
          Item: "Classic Shirt",
          Qty: 8,
          "Price Point Name": "Grey",
          SKU: "SHRT-GRY-YM",
          "Modifiers Applied": "Youth Medium",
          "Gross Sales": 200,
          Discounts: 0,
          "Net Sales": 200,
          Tax: 0
        },
        {
          Date: "2024-03-09",
          Time: "12:20:00",
          "Time Zone": "America/Toronto",
          Category: "Rinkside Classic",
          Item: "Add-On $5",
          Qty: 9,
          "Gross Sales": 45,
          Discounts: 0,
          "Net Sales": 45,
          Tax: 0
        },
        {
          Date: "2024-03-09",
          Time: "12:25:00",
          "Time Zone": "America/Toronto",
          Category: "Rinkside Classic",
          Item: "Add-On $10",
          Qty: 3,
          "Gross Sales": 30,
          Discounts: 0,
          "Net Sales": 30,
          Tax: 0
        }
      ];

      function safeReadStorage(key) {
        try {
          return window.localStorage.getItem(key);
        } catch (error) {
          return null;
        }
      }

      function safeWriteStorage(key, value) {
        try {
          if (value) {
            window.localStorage.setItem(key, value);
          } else {
            window.localStorage.removeItem(key);
          }
        } catch (error) {
        }
      }

      function setEventStatus(message, tone = "info") {
        if (!eventElements.status) {
          return;
        }
        eventElements.status.textContent = message;
        eventElements.status.dataset.tone = tone;
      }

      function updateEventLoadingUi() {
        const syncBusy = Boolean(eventLoadingState.sync);
        const fetchBusy = Boolean(eventLoadingState.fetch);
        if (eventElements.syncButton) {
          eventElements.syncButton.disabled = syncBusy;
          eventElements.syncButton.textContent = syncBusy ? 'Syncing...' : 'Sync Square';
        }
        if (eventElements.loadButton) {
          eventElements.loadButton.disabled = fetchBusy;
          eventElements.loadButton.textContent = fetchBusy ? 'Fetching...' : 'Fetch Data';
        }
        if (eventElements.sampleButton) {
          eventElements.sampleButton.disabled = fetchBusy;
        }
        if (eventElements.lockButton) {
          eventElements.lockButton.disabled = syncBusy;
        }
      }

      function setEventLoading(mode, isLoading) {
        if (!Object.prototype.hasOwnProperty.call(eventLoadingState, mode)) {
          return;
        }
        eventLoadingState[mode] = Boolean(isLoading);
        updateEventLoadingUi();
      }

      function clearCanvas(canvasEl) {
        if (!canvasEl) {
          return;
        }
        const ctx = canvasEl.getContext("2d");
        if (ctx) {
          ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);
        }
      }

      function makeAccessor(row) {
        const map = {};
        Object.keys(row).forEach((key) => {
          if (typeof key === "string") {
            map[key.trim().toLowerCase()] = row[key];
          }
        });
        return (keys) => {
          for (const key of keys) {
            const normalized = key.toLowerCase();
            if (Object.prototype.hasOwnProperty.call(map, normalized)) {
              const value = map[normalized];
              if (value !== undefined && value !== null && value !== "") {
                return value;
              }
            }
          }
          return undefined;
        };
      }

      function safeNumber(value) {
        if (typeof value === "number" && Number.isFinite(value)) {
          return value;
        }
        if (typeof value === "string") {
          const cleaned = value.replace(/[^0-9.-]/g, "");
          const parsed = Number(cleaned);
          if (Number.isFinite(parsed)) {
            return parsed;
          }
        }
        return 0;
      }

      function normalizeSizeValue(value) {
        if (!value && value !== 0) {
          return null;
        }
        const str = String(value).trim();
        if (!str) {
          return null;
        }
        const direct = str.toUpperCase();
        if (SIZES.includes(direct)) {
          return direct;
        }
        const lower = str.toLowerCase();
        if (SIZE_ALIASES[lower]) {
          return SIZE_ALIASES[lower];
        }
        const collapsed = lower.replace(/[^a-z0-9]/g, "");
        if (SIZE_SYNONYMS[collapsed]) {
          return SIZE_SYNONYMS[collapsed];
        }
        for (const size of SIZES) {
          if (lower.includes(size.toLowerCase())) {
            return size;
          }
        }
        const tokens = lower.split(/[^a-z0-9]+/).filter(Boolean);
        for (const token of tokens) {
          if (SIZE_SYNONYMS[token]) {
            return SIZE_SYNONYMS[token];
          }
          const alias = SIZE_ALIASES[token];
          if (alias) {
            return alias;
          }
          const upperToken = token.toUpperCase();
          if (SIZES.includes(upperToken)) {
            return upperToken;
          }
        }
        return null;
      }

      function detectProductType(item, variation) {
        const normalizedItem = (item || '').trim().toLowerCase();
        if (normalizedItem) {
          if (["add-on $5", "add-on$5", "add on $5", "addon $5", "add-ons $5"].includes(normalizedItem.replace(/\s+/g, ' '))) {
            return 'addon5';
          }
          if (["add-on $10", "add-on$10", "add on $10", "addon $10", "add-ons $10"].includes(normalizedItem.replace(/\s+/g, ' '))) {
            return 'addon10';
          }
        }

        const raw = `${item || ''} ${variation || ''}`;
        const lower = raw.toLowerCase();
        const combined = lower.replace(/[-\u2013\u2014\u2212]/g, '-');
        const collapsed = combined.replace(/\s+/g, ' ').trim();
        if (!collapsed) {
          return null;
        }
        if (/add[\s-]?on[s]?\s*\$?\s*5\b/.test(collapsed)) {
          return 'addon5';
        }
        if (/add[\s-]?on[s]?\s*\$?\s*10\b/.test(collapsed)) {
          return 'addon10';
        }
        if (PRODUCT_KEYWORDS.hoodie.some((keyword) => collapsed.includes(keyword))) {
          return 'hoodie';
        }
        if (PRODUCT_KEYWORDS.shirt.some((keyword) => collapsed.includes(keyword))) {
          return 'shirt';
        }
        if (PRODUCT_KEYWORDS.addon5.some((keyword) => collapsed.includes(keyword))) {
          return 'addon5';
        }
        if (PRODUCT_KEYWORDS.addon10.some((keyword) => collapsed.includes(keyword))) {
          return 'addon10';
        }
        return null;
      }

      function normalizePayloadToRows(payload) {
        if (!payload) {
          return [];
        }
        if (Array.isArray(payload)) {
          return payload;
        }
        const candidates = ["rows", "data", "records", "items", "result"];
        for (const key of candidates) {
          if (Array.isArray(payload[key])) {
            return payload[key];
          }
        }
        return [];
      }

      function buildEventRecords(rows) {
        const eventsMap = new Map();
        let latest = null;

        rows.forEach((row) => {
          if (!row || typeof row !== "object" || Array.isArray(row)) {
            return;
          }
          const accessor = makeAccessor(row);
          const eventName = cleanEventName(accessor(EVENT_FIELD_HINTS.eventName));
          if (!eventName) {
            return;
          }
          const eventKey = cleanEventName(accessor(EVENT_FIELD_HINTS.eventKey)) || eventName;
          const categoryRaw = accessor(EVENT_FIELD_HINTS.category);
          const category = categoryRaw ? String(categoryRaw).trim() : "All Events";
          const itemValue = accessor(EVENT_FIELD_HINTS.product);
          const variationValue = accessor(EVENT_FIELD_HINTS.variation);
          const productType = detectProductType(itemValue, variationValue);
          const quantityValue = accessor(EVENT_FIELD_HINTS.quantity);
          const quantity = safeNumber(quantityValue);
          const sizeValue = normalizeSizeValue(accessor(EVENT_FIELD_HINTS.size) || variationValue || itemValue);
          const timestampValue = accessor(EVENT_FIELD_HINTS.timestamp);
          const dateValue = accessor(EVENT_FIELD_HINTS.date);
          const timeValue = accessor(EVENT_FIELD_HINTS.time);
          const timeZoneValue = accessor(EVENT_FIELD_HINTS.timeZone);
          let timestamp = null;
          const pushTimestamp = (value) => {
            if (value && !timestamp) {
              const parsed = new Date(value);
              if (!Number.isNaN(parsed.valueOf())) {
                timestamp = parsed;
              }
            }
          };
          pushTimestamp(timestampValue);
          if (!timestamp && dateValue) {
            const datePart = String(dateValue).trim();
            const timePartRaw = timeValue ? String(timeValue).trim() : "";
            const timePart = timePartRaw || "00:00:00";
            const tzPart = timeZoneValue ? String(timeZoneValue).trim() : "";
            const candidate = tzPart ? `${datePart} ${timePart} ${tzPart}` : `${datePart} ${timePart}`;
            pushTimestamp(candidate);
            if (!timestamp) {
              pushTimestamp(`${datePart}T${timePart}`);
            }
          }

          let record = eventsMap.get(eventKey);
          if (!record) {
            record = {
              id: eventKey,
              name: eventName,
              category,
              hoodies: { counts: Array(SIZES.length).fill(0), total: 0 },
              shirts: { counts: Array(SIZES.length).fill(0), total: 0 },
              addOn5: 0,
              addOn10: 0,
              addOn5APS: 0,
              addOn10APS: 0,
              totalUnits: 0,
              lastSale: null,
              rows: []
            };
            const venueRaw = accessor(EVENT_FIELD_HINTS.venue);
            if (venueRaw) {
              record.venue = String(venueRaw).trim();
            }
            eventsMap.set(eventKey, record);
          }

          record.rows.push(row);

          if (timestamp && (!record.lastSale || timestamp > record.lastSale)) {
            record.lastSale = timestamp;
          }
          if (timestamp && (!latest || timestamp > latest)) {
            latest = timestamp;
          }

          if (productType === "hoodie" || productType === "shirt") {
            if (!sizeValue || quantity === 0) {
              return;
            }
            const index = SIZES.indexOf(sizeValue);
            if (index >= 0) {
              const bucket = productType === "hoodie" ? record.hoodies : record.shirts;
              bucket.counts[index] += quantity;
              bucket.total += quantity;
              record.totalUnits += quantity;
            }
          } else if (productType === "addon5") {
            record.addOn5 += quantity;
          } else if (productType === "addon10") {
            record.addOn10 += quantity;
          }
        });

        const events = Array.from(eventsMap.values());
        events.forEach((record) => {
          const denominator = record.hoodies.total + record.shirts.total;
          record.addOn5APS = denominator > 0 ? record.addOn5 / denominator : 0;
          record.addOn10APS = denominator > 0 ? record.addOn10 / denominator : 0;
        });
        events.sort((a, b) => {
          if (a.lastSale && b.lastSale) {
            return b.lastSale - a.lastSale;
          }
          if (a.lastSale) {
            return -1;
          }
          if (b.lastSale) {
            return 1;
          }
          return a.name.localeCompare(b.name);
        });

        eventState.events = events;
        eventState.lastUpdated = latest;
      }

      function shareByIndex(counts) {
        const total = counts.reduce((acc, value) => acc + value, 0);
        if (total <= 0) {
          return counts.map(() => 0);
        }
        return counts.map((value) => (value > 0 ? value / total : 0));
      }

      function formatInteger(value) {
        if (!Number.isFinite(value)) {
          return "0";
        }
        return Math.round(value).toLocaleString();
      }

      function cleanEventName(value) {
        if (!value && value !== 0) {
          return "";
        }
        let result = String(value).trim();
        if (!result) {
          return "";
        }
        result = result.replace(/\s*\((?:payment|payments)[^)]*\)\s*$/i, "");
        result = result.replace(/\s+-\s+payment$/i, "");
        result = result.replace(/\s+/g, " " );
        return result.trim();
      }

      function formatNumber(value, { decimals = 2 } = {}) {
        if (!Number.isFinite(value)) {
          return (0).toFixed(decimals);
        }
        return value.toLocaleString(undefined, {
          minimumFractionDigits: decimals,
          maximumFractionDigits: decimals
        });
      }

      function renderEventPlaceholder(message) {
        resetEventMetrics();
        if (eventElements.tableBody) {
          eventElements.tableBody.innerHTML = "";
          const row = document.createElement("tr");
          const cell = document.createElement("td");
          cell.colSpan = 4;
          cell.className = "event-empty";
          cell.textContent = message;
          row.appendChild(cell);
          eventElements.tableBody.appendChild(row);
        }
        clearCanvas(eventElements.hoodieCanvas);
        clearCanvas(eventElements.shirtCanvas);
      }

      function resetEventMetrics() {
        const metrics = eventElements.metricDisplays;
        if (metrics.hoodies) metrics.hoodies.textContent = "0";
        if (metrics.shirts) metrics.shirts.textContent = "0";
        if (metrics.addon5) metrics.addon5.textContent = "0";
        if (metrics.addon10) metrics.addon10.textContent = "0";
        if (metrics.addon5APS) metrics.addon5APS.textContent = "0.00";
        if (metrics.addon10APS) metrics.addon10APS.textContent = "0.00";
        const totals = eventElements.totalDisplays;
        if (totals.hoodies) totals.hoodies.textContent = "0";
        if (totals.shirts) totals.shirts.textContent = "0";
        if (totals.combined) totals.combined.textContent = "0";
      }

      function renderEventTableRows(record) {
        if (!eventElements.tableBody) {
          return;
        }
        eventElements.tableBody.innerHTML = "";
        SIZES.forEach((size, index) => {
          const hoodieCount = record.hoodies.counts[index] || 0;
          const shirtCount = record.shirts.counts[index] || 0;
          const total = hoodieCount + shirtCount;
          const tr = document.createElement("tr");
          const cells = [
            size,
            formatInteger(hoodieCount),
            formatInteger(shirtCount),
            formatInteger(total)
          ];
          cells.forEach((value, cellIndex) => {
            const td = document.createElement("td");
            td.textContent = value;
            if (cellIndex === 0) {
              td.style.fontWeight = "600";
            }
            tr.appendChild(td);
          });
          eventElements.tableBody.appendChild(tr);
        });
      }

      function populateEventOptions(shouldRender = true) {
        if (!eventElements.eventSelect) {
          return;
        }
        const select = eventElements.eventSelect;
        const events = eventState.events;
        select.innerHTML = "";
        if (events.length === 0) {
          const option = document.createElement("option");
          option.value = "";
          option.textContent = "No events available";
          select.appendChild(option);
          select.disabled = true;
          renderEventPlaceholder(eventState.events.length ? "Select an event to view details." : "Load data to see hoodie and shirt distributions.");
          if (shouldRender) {
            eventState.selectedEventId = "";
          }
          return;
        }
        select.disabled = false;
        events.forEach((record) => {
          const option = document.createElement("option");
          option.value = record.id;
          option.textContent = record.name;
          select.appendChild(option);
        });
        if (!events.some((record) => record.id === eventState.selectedEventId)) {
          eventState.selectedEventId = events[0].id;
        }
        select.value = eventState.selectedEventId;
        if (shouldRender) {
          renderSelectedEvent();
        }
      }

      function renderSelectedEvent() {
        const events = eventState.events;
        const record = events.find((event) => event.id === eventState.selectedEventId);
        if (!record) {
          renderEventPlaceholder(events.length ? "Select an event to view details." : "Load data to see hoodie and shirt distributions.");
          return;
        }

        const metrics = eventElements.metricDisplays;
        if (metrics.hoodies) metrics.hoodies.textContent = formatInteger(record.hoodies.total);
        if (metrics.shirts) metrics.shirts.textContent = formatInteger(record.shirts.total);
        if (metrics.addon5) metrics.addon5.textContent = formatInteger(record.addOn5);
        if (metrics.addon10) metrics.addon10.textContent = formatInteger(record.addOn10);
        if (metrics.addon5APS) metrics.addon5APS.textContent = formatNumber(record.addOn5APS, { decimals: 2 });
        if (metrics.addon10APS) metrics.addon10APS.textContent = formatNumber(record.addOn10APS, { decimals: 2 });

        const totals = eventElements.totalDisplays;
        if (totals.hoodies) totals.hoodies.textContent = formatInteger(record.hoodies.total);
        if (totals.shirts) totals.shirts.textContent = formatInteger(record.shirts.total);
        if (totals.combined) totals.combined.textContent = formatInteger(record.hoodies.total + record.shirts.total);

        renderEventTableRows(record);

        const hoodieShares = shareByIndex(record.hoodies.counts);
        const shirtShares = shareByIndex(record.shirts.counts);
        drawHistogram(eventElements.hoodieCanvas, record.hoodies.counts, {
          percentages: hoodieShares,
          yLabel: "units",
          colors: { from: "rgba(119, 167, 255, 0.95)", to: "rgba(80, 122, 255, 0.82)" }
        });
        drawHistogram(eventElements.shirtCanvas, record.shirts.counts, {
          percentages: shirtShares,
          yLabel: "units",
          colors: { from: "rgba(255, 166, 133, 0.9)", to: "rgba(232, 112, 134, 0.82)" }
        });

        safeWriteStorage(EVENT_STORAGE_KEYS.eventId, eventState.selectedEventId);
      }

      function applyEventRows(rows) {
        eventState.rawRows = rows;
        buildEventRecords(rows);
        populateEventOptions(true);
        if (eventState.events.length === 0) {
          setEventStatus("No hoodie or shirt rows were found. Confirm the sheet headers and item names.", "error");
        } else {
          const messageParts = [`${eventState.events.length} event${eventState.events.length === 1 ? "" : "s"} loaded`];
          if (eventState.lastUpdated) {
            messageParts.push(`Latest transaction ${eventState.lastUpdated.toLocaleString()}`);
          }
          setEventStatus(messageParts.join(" - "), "success");
        }
      }

      async function triggerSync(url) {
        const response = await fetch(url, { cache: 'no-store' });
        if (!response.ok) {
          throw new Error(`${response.status} ${response.statusText}`);
        }
        const contentType = response.headers.get('content-type') || '';
        if (contentType.includes('application/json')) {
          const payload = await response.json();
          if (payload && typeof payload === 'object') {
            if (payload.message) return payload.message;
            if (payload.status) return String(payload.status);
          }
          return 'Sync complete.';
        }
        const text = await response.text();
        if (text) {
          try {
            const parsed = JSON.parse(text);
            if (parsed && typeof parsed === 'object') {
              if (parsed.message) return parsed.message;
              if (parsed.status) return String(parsed.status);
            }
          } catch (error) {
            // fall through to plain text
          }
          return text.trim();
        }
        return 'Sync complete.';
      }

      async function syncSquare() {
        if (!ensureSecretProvided()) {
          return;
        }
        const syncUrl = getActionUrl('sync');
        if (!syncUrl) {
          setEventStatus('Enter the Apps Script web app URL first.', 'error');
          return;
        }
        setEventLoading('sync', true);
        try {
          setEventStatus('Syncing Square data via Apps Script...', 'info');
          const syncMessage = await triggerSync(syncUrl);
          eventState.syncTimestamp = new Date();
          updateSyncFetchDisplay();
          const cleaned = syncMessage && syncMessage.trim() ? syncMessage.trim() : 'Sync complete.';
          setEventStatus(`${cleaned} Run Fetch Data to refresh the dashboard.`, 'info');
        } catch (error) {
          console.error(error);
          setEventStatus(`Square sync failed: ${error.message}`, 'error');
        } finally {
          setEventLoading('sync', false);
        }
      }

      async function fetchSquareData({ statusMessage } = {}) {
        if (!ensureSecretProvided()) {
          return;
        }
        const fetchUrl = getActionUrl('fetch');
        if (!fetchUrl) {
          setEventStatus('Enter the Apps Script web app URL first.', 'error');
          return;
        }
        try {
          await hydrateFromUrl(fetchUrl, { statusMessage: statusMessage || 'Fetching event data...' });
        } catch (error) {
          console.error('Fetch sequence failed', error);
          setEventLoading('fetch', false);
          setEventStatus(`Fetch failed: ${error.message}`, 'error');
        }
      }

      const FETCH_TIMEOUT_MS = 20000;

      async function hydrateFromUrl(rawUrl, { skipLoadingToggle = false, statusMessage } = {}) {
        const url = rawUrl ? rawUrl.trim() : "";
        if (!url) {
          setEventStatus("Enter the Apps Script web app URL first.", "error");
          return;
        }
        try {
          const parsed = new URL(url);
          if (parsed.protocol !== "https:" && parsed.protocol !== "http:") {
            setEventStatus("Use an http or https URL.", "error");
            return;
          }
        } catch (error) {
          setEventStatus("Enter a valid URL to load data.", "error");
          return;
        }

        if (!skipLoadingToggle) {
          setEventLoading('fetch', true);
        }
        setEventStatus(statusMessage || "Loading event data...", "info");

        const controller = typeof AbortController !== 'undefined' ? new AbortController() : null;
        const abortTimeout = controller ? window.setTimeout(() => {
          try {
            controller.abort();
          } catch (error) {}
        }, FETCH_TIMEOUT_MS) : null;

        try {
          const response = await fetch(url, { cache: "no-store", signal: controller ? controller.signal : undefined });
          if (abortTimeout !== null) {
            window.clearTimeout(abortTimeout);
          }
          if (!response.ok) {
            throw new Error(`${response.status} ${response.statusText}`);
          }
          const contentType = response.headers.get("content-type") || "";
          let payload;
          if (contentType.includes("application/json")) {
            payload = await response.json();
          } else {
            const text = await response.text();
            payload = JSON.parse(text);
          }
          const rows = normalizePayloadToRows(payload);
          if (!rows.length) {
            throw new Error("No rows returned. Ensure your Apps Script returns an array of objects.");
          }
          applyEventRows(rows);
          eventState.fetchTimestamp = new Date();
          updateSyncFetchDisplay();
          const base = eventState.urls ? eventState.urls.base : normalizeBaseUrl(url);
          if (base) {
            safeWriteStorage(EVENT_STORAGE_KEYS.source, base);
          }
        } catch (error) {
          console.error(error);
          const isAbort = error && (error.name === 'AbortError' || error.message === 'The user aborted a request.');
          const message = isAbort ? 'Fetch timed out. Try again or verify the Apps Script deployment.' : `Failed to load data: ${error.message}`;
          setEventStatus(message, "error");
        } finally {
          if (abortTimeout !== null) {
            window.clearTimeout(abortTimeout);
          }
          if (!skipLoadingToggle) {
            setEventLoading('fetch', false);
          }
        }
      }

      function loadSampleData() {
        applyEventRows(SAMPLE_EVENT_DATA);
        setEventStatus("Loaded sample data. Replace with your live Apps Script feed when ready.", "info");
      }

      function initializeEventExplorer() {
        const savedTab = safeReadStorage(APP_STORAGE_KEYS.activeTab) || 'projection';
        setActiveTab(savedTab, { persist: false });
        const savedSource = safeReadStorage(EVENT_STORAGE_KEYS.source);
        if (eventElements.sourceInput && savedSource) {
          eventElements.sourceInput.value = savedSource;
        }
        const savedSecret = safeReadStorage(EVENT_STORAGE_KEYS.secret);
        const savedLock = safeReadStorage(APP_STORAGE_KEYS.urlLocked) === '1';
        if (savedLock && typeof savedSecret === 'string') {
          if (eventElements.secretInput) {
            eventElements.secretInput.value = savedSecret;
          }
          setSecretValue(savedSecret, { persist: false });
          setUrlLocked(true);
        } else {
          setUrlLocked(false);
        }
        const savedEventId = safeReadStorage(EVENT_STORAGE_KEYS.eventId);
        if (savedEventId) {
          eventState.selectedEventId = savedEventId;
        }
        renderEventPlaceholder("Load data to see hoodie and shirt distributions.");
        if (savedSource && savedSecret && savedLock) {
          fetchSquareData({ statusMessage: 'Loading saved event data...' }).catch((error) => {
            console.error('Initial fetch failed', error);
            setEventLoading('fetch', false);
          });
        }
      }

      if (eventElements.syncButton) {
        eventElements.syncButton.addEventListener('click', () => {
          flashButton(eventElements.syncButton);
          syncSquare();
        });
      }

      if (eventElements.loadButton) {
        eventElements.loadButton.addEventListener('click', () => {
          flashButton(eventElements.loadButton);
          fetchSquareData();
        });
      }

      if (eventElements.sampleButton) {
        eventElements.sampleButton.addEventListener('click', () => {
          flashButton(eventElements.sampleButton);
          loadSampleData();
        });
      }

      if (eventElements.sourceInput) {
        eventElements.sourceInput.addEventListener("change", (event) => {
          const value = event.target.value ? event.target.value.trim() : "";
          safeWriteStorage(EVENT_STORAGE_KEYS.source, value);
          eventState.urls = null;
        });
      }

      if (eventElements.secretInput) {
        const updateSecret = (persist) => (event) => {
          setSecretValue(event.target.value, { persist });
        };
        eventElements.secretInput.addEventListener('input', updateSecret(false));
        eventElements.secretInput.addEventListener('change', updateSecret(true));
      }

      if (eventElements.eventSelect) {
        eventElements.eventSelect.addEventListener("change", (event) => {
          eventState.selectedEventId = event.target.value || "";
          safeWriteStorage(EVENT_STORAGE_KEYS.eventId, eventState.selectedEventId);
          renderSelectedEvent();
        });
      }

      initializeEventExplorer();


</script>
  </body>
</html>
